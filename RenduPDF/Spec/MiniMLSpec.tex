\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  12pt,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\usepackage{stmaryrd}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Palatino}
  \setsansfont[]{Helvetica}
  \setmonofont[]{Menlo}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin = 1.2in]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
\ifPDFTeX
\else
\babelfont[french]{rm}[]{Palatino}
\fi
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={MiniML Spec},
  pdfauthor={Fazazi Zeid; Luo Yukai; Dibassi Brahima},
  pdflang={fr},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={NavyBlue},
  pdfcreator={LaTeX via pandoc}}

\title{MiniML Spec}
\author{Fazazi Zeid \and Luo Yukai \and Dibassi Brahima}
\date{2023-05-06}

\begin{document}
\maketitle

\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\allowdisplaybreaks
\pagebreak

\hypertarget{grammaire}{%
  \section{Grammaire}\label{grammaire}}


\newcommand{\grammarRule}[1]{\; \textbf{<\textcolor{Blue}{#1}>} \;}
\newcommand{\grammarRuleUnSpaced}[1]{\textbf{<\textcolor{Blue}{#1}>}}
\newcommand{\nTime}[1]{\; #1\text{*} \;}
\newcommand{\nPlus}[1]{\; #1\text{+} \;}
\newcommand{\isToken}[1]{\; \textit{`\textcolor{Maroon}{#1}`} \;}
\newcommand{\isTokenLCBPV}[1]{\; \textit{`\textcolor{Green}{#1}`} \;}
\newcommand{\isRangeToken}[2]{\; \textit{`\textcolor{Maroon}{#1} - \textcolor{Maroon}{#2}`} \;}
\newcommand{\isExtentionML}[1]{ \textit{\textcolor{Orange}{#1}} \quad }

Voici la grammaire BNF du language MiniML.\
Les extensions non compatibles avec Ocaml mais compatible avec \textbf{Autobill} sont en \textcolor{Orange}{Orange}.

\hypertarget{Elements Nommés}{%
  \subsection{Elements Nommés}\label{Elements Nommés}}

\begin{align*}
  \grammarRule{Id} ::= \quad             & \nPlus{[\isRangeToken{a}{z} \isRangeToken{A}{Z} \isRangeToken{0}{9} \isToken{\_}]} \\
  \grammarRule{ConstructeurId} ::= \quad & [\isRangeToken{A}{Z}] \grammarRule{Id}                                             \\
  \grammarRule{Vartype} ::= \quad        & \isToken{'}[\isRangeToken{a}{z}] \; \nTime{[\isRangeToken{0}{9}]}
\end{align*}

\hypertarget{programmes}{%
  \subsection{Programmes}\label{programmes}}


\begin{align*}
  \grammarRule{Prog} ::= \quad & |\quad \grammarRule{Expr}                                  \\
                               & |\quad \grammarRule{Def}  \isToken{;;}  \grammarRule{Prog}
\end{align*}

\hypertarget{definitions}{%
  \subsection{Definitions}\label{definitions}}

\begin{align*}
  \grammarRule{Def} ::= \quad              & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr}                                                  \\
                                           & |\quad \isToken{type} \nTime{\grammarRuleUnSpaced{Vartype}} \grammarRule{Id} \isToken{=} \grammarRule{NewContructors} \\
  \\
  \grammarRule{NewContructors} ::=   \quad & |\quad  \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}                                                  \\
                                           & |\quad  \grammarRule{NewContructors} \isToken{|} \grammarRule{NewContructors}                                         \\
  \isExtentionML{Debut Extension}          & |\quad \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}  \isToken{with}  \grammarRule{ParamAssigns}       \\
  \\
  \grammarRule{ParamAssigns} ::= \quad     & |\quad \grammarRule{VarType} \isToken{=} \grammarRule{ParmExpr}                                                       \\
                                           & |\quad \grammarRule{ParamAssigns} \isToken{,} \grammarRule{ParamAssigns}                                              \\
  \grammarRule{ParmExpr} ::= \quad
                                           & |\quad \isToken{1}                                                                                                    \\
                                           & |\quad \grammarRule{VarType}                                                                                          \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{+} \grammarRule{ParmExpr}                                                      \\
  \isExtentionML{Fin Extension}            & |\quad \grammarRule{ParmExpr} \isToken{*} \grammarRule{ParmExpr}                                                      \\
\end{align*}
\pagebreak

\hypertarget{expressions}{%
  \subsection{Expressions}\label{expressions}}
\begin{align*}
  \grammarRule{Litteral}  \quad ::=  \quad       & |\quad \nPlus{[\isRangeToken{0}{9}]}                                                                                                                                                  \\
                                                 & |\quad [\isToken{true}|\isToken{false}]                                                                                                                                               \\
                                                 & |\quad \isToken{(} \isToken{)}                                                                                                                                                        \\
  \\
  \grammarRule{Expr}  \quad ::=  \quad           & |\quad \grammarRule{Litteral}                                                                                                                                                         \\
                                                 & |\quad \grammarRule{Id}                                                                                                                                                               \\
                                                 & |\quad \grammarRule{UnaryOperator}  \grammarRule{Expr}                                                                                                                                \\
                                                 & |\quad  \grammarRule{Expr} \grammarRule{BinaryOperator}    \grammarRule{Expr}                                                                                                         \\
                                                 & |\quad \grammarRule{Expr}  \grammarRule{Expr}                                                                                                                                         \\
                                                 & |\quad \grammarRule{Expr} \isToken{,}  \grammarRule{Expr}                                                                                                                             \\
                                                 & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr} \isToken{in} \grammarRule{Expr}                                                                                  \\
                                                 & |\quad \isToken{fun} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                                                                                                \\
                                                 & |\quad \isToken{fun} \isToken{rec} \grammarRule{Id} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                                                                 \\
                                                 & |\quad \grammarRule{ConstructeurId}  \grammarRule{Expr}                                                                                                                               \\
                                                 & |\quad \isToken{match} \grammarRule{Expr} \isToken{with} \grammarRule{MatchCase}                                                                                                      \\
  \\
  \grammarRule{UnaryOperator}  \quad ::=  \quad  & \isToken{not}                                                                                                                                                                         \\
  \grammarRule{BinaryOperator}  \quad ::=  \quad & [\isToken{and} \,|\, \isToken{or} \,|\, \isToken{+} \,|\, \isToken{-} \,|\, \isToken{/} \,|\, \isToken{\%} \,|\, \isToken{*} \,|\, \isToken{<} \,|\, \isToken{>}  \,|\, \isToken{=} ] \\
\end{align*}

\hypertarget{filtrage-et-motifs}{%
  \subsection{Filtrage et Motifs}\label{filtrage-et-motifs}}
\begin{align*}
  \grammarRule{MatchCase}  \quad ::=  \quad & |\quad  \grammarRule{Pattern} \isToken{->}  \grammarRule{Expr}     \\
                                            & |\quad \grammarRule{MatchCase} \isToken{|} \grammarRule{MatchCase} \\
  \\
  \grammarRule{Pattern} \quad ::=  \quad    & |\quad \grammarRule{Litteral}                                      \\
                                            & |\quad \grammarRule{Id}                                            \\
                                            & |\quad \grammarRule{Pattern}  \isToken{,} \grammarRule{Pattern}    \\
                                            & |\quad \grammarRule{ConstructeurId} \; \grammarRule{Pattern}       \\
\end{align*}

\pagebreak

\hypertarget{types-1}{%
  \subsection{Types}\label{types-1}}

\begin{align*}
  \grammarRule{Type}    \quad ::=  \quad & |\quad \grammarRule{Vartype}                              \\
                                         & |\quad \grammarRule{Id}                                   \\
                                         & |\quad \grammarRule{Type}   \grammarRule{Type}            \\
                                         & |\quad \grammarRule{Type} \isToken{->} \grammarRule{Type} \\
                                         & |\quad \grammarRule{Type} \isToken{*}  \grammarRule{Type} \\
\end{align*}

\hypertarget{semantique-de-traduction}{%
  \section{Semantique de traduction}\label{semantique-de-traduction}}

\newcommand{\translateNode}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\translateResult}[1]{\llbracket #1 \rrbracket}
\newcommand{\isElemMiniML}[1]{\; \textcolor{Maroon}{#1} \;}
\newcommand{\isElemLCBPV}[1]{\textcolor{ForestGreen}{#1}}
\newcommand{\spaced}[1]{\; #1 \;}
\newcommand{\Tab}{\quad \quad \quad \quad \quad \quad \;}
\hypertarget{notation}{%
  \subsection{Notation}\label{notation}}
$ \translateNode{let \; v \; = \; e_1 \; in \; e_2}{Expr}  \rightarrow let \; v = \; \translateResult{e_1} \; in \; \translateResult{e_2}$
\begin{itemize}
  \tightlist
  \item
        $\translateNode{\_}{Expr}  \rightarrow $ est la traduction d'un noeud expr du langage MiniML vers le langage LCBPV
        \begin{itemize}
          \tightlist
          \item
                À l'interieur des $\translateResult{}$, on trouve les elements propre au langage MiniML qui sont traduit vers le langage LCBPV.
          \item
                À l'exterieur des $\translateResult{}$, on trouve les elements propre au langage LCBPV.
        \end{itemize}
  \item
        $X_n$ est le n-ième sous-noeud de l'arbre de syntaxe abstrait. \newline
        Selon les cas $X$ peut être :
        \begin{itemize}
          \tightlist
          \item
                $e$ pour les expressions
          \item
                $p$ pour les motifs
          \item
                $t$ pour les types
          \item
                $d$ pour les définitions
                \begin{itemize}
                  \tightlist
                  \item
                        $dc$ pour les définitions de constructeurs
                \end{itemize}
          \item
                $v$ pour les elements nommées
          \item
                $l$ pour les litteraux
        \end{itemize}
  \item
        $X_1 \dots X_n$ est la liste des sous-noeuds de type $X$ allant de $1$ à $n$
\end{itemize}

\hypertarget{programmes-1}{%
  \subsection{Programmes}\label{programmes-1}}

Un programme MiniML est une suite de taille arbitraire de définitions suivie d'une expression.

\begin{align*}
  \translateNode{d_1 \dots d_n \, e}{Prog} \rightarrow \translateResult{d_1 \dots d_n}\; return \; \translateResult{e}
\end{align*}

\pagebreak

\subsection{Définitions}\label{def}

On définit l'operation de traduction \(\translateNode{\_}{Def}\) selon les cas de construction
des définitions précisées par la règle de grammaire : \grammarRule{Def}

On distingue deux noeuds de types \grammarRule{Def}:
\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Variables Globales},
  \item
        Les définitions de \textbf{Types}.
\end{itemize}
\begin{align*}
  \text{(VARDEF)}  \quad & \translateNode{let \, v \, = \, e}{Def} \rightarrow   let \, v \, = \; \translateResult{e}       \\
  \text{(TYPDEF) } \quad & \translateNode{type \, \, v_1 \dots v_N \, = \, dc_1 \dots  dc_N}{Def}                           \\
  \rightarrow \;         & data \translateResult{v_1} (\translateResult{\dots v_N} : +) = \translateResult{dc_1 \dots dc_N} \\
\end{align*}
\subsubsection{Définitions de Constructeurs}\label{defConstruct}

On définit l'operation de traduction \(\translateNode{\_}{DefContructors}\) selon les cas de construction précisées par la règle de grammaire : \grammarRule{NewContructors}

On distingue deux noeuds de types \grammarRule{NewContructors}:
\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Constructeurs Classiques} qui sont compatibles avec OcamL.
  \item
        Les définitions de \textbf{Constructeurs Equationnels} qui sont une extension spécifique pour \textbf{Autobill} incompatible avec OcamL et dont la traduction n'est pas encore totalement définie.
\end{itemize}
\begin{align*}
  \text{(MLCONSTRUCTDEF)} \quad & \translateNode{v \; of \; t}{DefContructors}   \rightarrow   v\translateResult{t} \\
\end{align*}

\subsection{Types}\label{types-2}

On définit l'operation de traduction \(\translateNode{\_}{Type}\) selon les cas de construction
des types précisées par la règle de grammaire : \grammarRule{Type}

On distingue 4 noeuds de types $Type$:
\begin{itemize}
  \tightlist
  \item
        Les \textbf{Variables de types}.
  \item
        Les \textbf{Applications de types}.
  \item
        Les \textbf{Lambda}.
  \item
        Les \textbf{Tuples}.
\end{itemize}
\begin{align*}
  \text{(TVAR) }  & \translateNode{v}{Type} \rightarrow  v                                                                                          \\
  \text{(TAPP) }  & \translateNode{t_1 t_2}{Type} \rightarrow  \translateResult{t_1} \, \translateResult{t_2}                                       \\
  \text{(TCLOS) } & \translateNode{t_1 \text{->} t_2}{Type} \rightarrow  Exp (Fun\translateResult{t_1} \, \text{->} \, Thunk\translateResult{t_2} ) \\
  \text{(TTUPLE)} & \translateNode{t_1 * t_2}{Type} \rightarrow  \translateResult{t_1} \,  \, \translateResult{t_2}
\end{align*}

\subsection{Expressions}\label{exprs}

On définit l'operation de traduction \(\translateNode{\_}{Expr}\) selon les cas de construction
des expressions précisées par la règle de grammaire : \grammarRule{Expr}

On distingue 7 noeuds d'intérêts de types \grammarRule{Expr}:
\begin{itemize}
  \tightlist
  \item
        Les \textbf{Tuples}.
  \item
        Les \textbf{Appels de fonctions}.
  \item
        Les \textbf{Fixation}.
  \item
        Les \textbf{Lambda}.
  \item
        Les \textbf{Fonctions Recursive}.
  \item
        Les \textbf{Constructions}.
  \item
        Les \textbf{Correspondance de motifs}.
\end{itemize}
\textbf{Note:} On ne prend pas en compte les \textbf{Litteraux} et les \textbf{Variables} dans ce descriptif car leurs traductions sont directes.
\begin{align*}
  \text{(TUPLE)} \quad     & \translateNode{e_1 \, , \, e_2}{Expr} \rightarrow \text{Tuple}(\translateResult{e_1} \, \, \translateResult{e_2})                                                            \\
  \text{(LAMBDA)} \quad    & \translateNode{fun \, v \, \rightarrow \, e}{Expr}    \rightarrow  exp(  \; get \; | \; call(v) \; \text{->}  \; thunk\translateResult{e}  )                                   \\
  \text{(FUN REC)} \quad   & \translateNode{fun \, rec \, v_1 \, v_2 \rightarrow \, e}{Expr}      \rightarrow exp( \; rec \; v_1 \; is \; get \; | \; call(v_2) \; \text{->}  \; thunk\translateResult{e} ) \\
  \text{(CALL)} \quad      & \translateNode{e_1 e_2}{Expr}     \rightarrow  \{                                                                                                                              \\
                           & \Tab open \; exp \; v_1  = \translateResult{e_1}                                                                                                                               \\
                           & \Tab force \; thunk(v_2) = (v_1).call\translateResult{e_2}                                                                                                                     \\
                           & \Tab return \; v_2                                                                                                                                                             \\
                           & \}                                                                                                                                                                             \\
  \text{(BIND)} \quad      & \translateNode{let \; v \; = \; e_1 \; in \; e_2}{Expr}  \rightarrow  \{                                                                                                       \\
                           & \Tab let \; v = \translateResult{e_1}                                                                                                                                          \\
                           & \Tab return \;\translateResult{e_2}                                                                                                                                            \\
                           & \}                                                                                                                                                                             \\
  \text{(CONSTRUCT)} \quad & \translateNode{v \, e}{Expr} \rightarrow v(\translateResult{e})                                                                                                                \\
  \text{(MATCH)} \quad     & \translateNode{match \, e \, with \, p_1 \dots p_N }{Expr}\rightarrow  match \, \translateResult{e} \, with \, \translateResult{p_1} \dots \translateResult{p_N} \; end        \\
\end{align*}

\pagebreak
\subsection{Motifs et Filtrage}\label{motifs-et-filtrage}

On définit l'operation de traduction \(\translateNode{\_}{Case}\) selon les cas de construction
des expressions précisées par la règle de grammaire : \grammarRule{MatchCase}

On distingue 4 noeuds d'intérêt de types \grammarRule{MatchCase}:
\begin{itemize}
  \tightlist
  \item
        Les patterns sur \textbf{Litteraux}.
  \item
        Les patterns sur \textbf{Variables}.
  \item
        Les patterns sur \textbf{Tuple}.
  \item
        Les patterns sur \textbf{Constructeurs}.
\end{itemize}

\begin{align*}
  \text{(PATTERN LIT)} \quad    & \translateNode{l \; \text{->} \; e}{MatchCase} \rightarrow \translateResult{l} \; \text{->} \; \translateResult{e}                             \\
  \text{(PATTERN VAR)} \quad    & \translateNode{v \; \text{->} \; e}{MatchCase} \rightarrow v \; \text{->} \; \translateResult{e}                             \\
  \text{(PATTERN TUPLE)} \quad  & \translateNode{v_1 \, , \, v_2 \, \text{->} \; e}{MatchCase} \rightarrow Tuple(v_1 \, \, v_2) \; \text{->} \; \translateResult{e}            \\
  \text{(PATTERN CONSTR)} \quad & \translateNode{v_1 \, v_2 \, \text{->} \; e}{MatchCase} \rightarrow v_1 \, v_2 \; \text{->} \; \translateResult{e} \\
\end{align*}

On notera que la traduction des patterns ne prend pas en compte les patterns profonds, c'est à dire les patterns imbriqués dans d'autres patterns.
En effet, les patterns profonds ne sont pas encore supportés par le language cible.

\end{document}
