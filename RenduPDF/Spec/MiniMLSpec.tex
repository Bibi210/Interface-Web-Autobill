\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  12pt,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\usepackage{stmaryrd}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Palatino}
  \setsansfont[]{Helvetica}
  \setmonofont[]{Menlo}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin = 1.2in]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
\ifPDFTeX
\else
\babelfont[french]{rm}[]{Palatino}
\fi
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={MiniML Spec},
  pdfauthor={Fazazi Zeid; Luo Yukai; Dibassi Brahima},
  pdflang={fr},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={NavyBlue},
  pdfcreator={LaTeX via pandoc}}

\title{MiniML Spec}
\author{Fazazi Zeid \and Luo Yukai \and Dibassi Brahima}
\date{2023-05-06}

\begin{document}
\maketitle

\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\allowdisplaybreaks
\pagebreak

\hypertarget{grammaire}{%
  \section{Grammaire}\label{grammaire}}

\newcommand{\grammarRule}[1]{\; \textbf{<\textcolor{Blue}{#1}>} \;}
\newcommand{\grammarRuleUnSpaced}[1]{\textbf{<\textcolor{Blue}{#1}>}}
\newcommand{\nTime}[1]{\; #1\text{*} \;}
\newcommand{\nPlus}[1]{\; #1\text{+} \;}
\newcommand{\isToken}[1]{\; \textit{`\textcolor{Maroon}{#1}`} \;}
\newcommand{\isTokenLCBPV}[1]{\; \textit{`\textcolor{Green}{#1}`} \;}
\newcommand{\isRangeToken}[2]{\; \textit{`\textcolor{Maroon}{#1} - \textcolor{Maroon}{#2}`} \;}

Voici la grammaire BNF du language MiniML.

\hypertarget{Identificateurs}{%
  \subsection{Identificateurs}\label{Identificateurs}}

\begin{align*}
  \grammarRule{Id} ::= \quad             & \nTime{[\isRangeToken{a}{z} \isRangeToken{A}{Z} \isRangeToken{0}{9} \isToken{\_}]} \\
  \grammarRule{ConstructeurId} ::= \quad & [\isRangeToken{A}{Z}] \grammarRule{Id}                                             \\
  \grammarRule{Vartype} ::= \quad        & \isToken{'}[\isRangeToken{a}{z}] \; \nTime{[\isRangeToken{0}{9}]}
\end{align*}

\hypertarget{programmes}{%
  \subsection{Programmes}\label{programmes}}


\begin{align*}
  \grammarRule{Prog} ::= \quad & |\quad \grammarRule{Expr}                                  \\
                               & |\quad \grammarRule{Def}  \isToken{;;}  \grammarRule{Prog}
\end{align*}

\hypertarget{definitions}{%
  \subsection{Definitions}\label{definitions}}

\begin{align*}
  \grammarRule{Def} ::= \quad              & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr}                                                  \\
                                           & |\quad \isToken{type} \nTime{\grammarRuleUnSpaced{Vartype}} \grammarRule{Id} \isToken{=} \grammarRule{NewContructors} \\
  \\
  \grammarRule{NewContructors} ::=   \quad & |\quad  \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}                                                  \\
                                           & |\quad \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}  \isToken{with}  \grammarRule{ParamAssigns}       \\
                                           & |\quad  \grammarRule{NewContructors} \isToken{|} \grammarRule{NewContructors}                                         \\
  \\
  \grammarRule{ParamAssigns} ::= \quad     & |\quad \grammarRule{VarType} \isToken{=} \grammarRule{ParmExpr}                                                       \\
                                           & |\quad \grammarRule{ParamAssigns} \isToken{,} \grammarRule{ParamAssigns}                                              \\
  \grammarRule{ParmExpr} ::= \quad
                                           & |\quad \isToken{1}                                                                                                    \\
                                           & |\quad \grammarRule{VarType}                                                                                          \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{+} \grammarRule{ParmExpr}                                                      \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{*} \grammarRule{ParmExpr}                                                      \\
\end{align*}
\pagebreak

\hypertarget{expressions}{%
  \subsection{Expressions}\label{expressions}}
\begin{align*}
  \grammarRule{Litteral}  \quad ::=  \quad & |\quad \nPlus{[\isRangeToken{0}{9}]}                                                                                                           \\
                                           & |\quad [\isToken{true}|\isToken{false}]                                                                                                        \\
                                           & |\quad \isToken{(} \isToken{)}                                                                                                                 \\
  \\
  \grammarRule{Expr}  \quad ::=  \quad     & |\quad \grammarRule{Litteral}                                                                                                                  \\
                                           & |\quad \grammarRule{Id}                                                                                                                        \\
                                           & |\quad \grammarRule{Operator}                                                                                                                  \\
                                           & |\quad \isToken{(} \grammarRule{Expr}  \grammarRule{Expr}         \isToken{)}                                                                  \\
                                           & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr} \isToken{in} \grammarRule{Expr}                                           \\
                                           & |\quad \isToken{fun} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                                                         \\
                                           & |\quad \isToken{fun} \isToken{rec} \grammarRule{Id} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                          \\
                                           & |\quad \grammarRule{ConstructeurId}  \nTime{\grammarRuleUnSpaced{Expr}}                                                                        \\
                                           & |\quad \isToken{match} \grammarRule{Expr} \isToken{with} \grammarRule{MatchCase}                                                               \\
  \\
  \grammarRule{Operator}  \quad ::=  \quad & [\isToken{+} \,|\, \isToken{-} \,|\, \isToken{/} \,|\, \isToken{\%} \,|\, \isToken{*} \,|\, \isToken{<} \,|\, \isToken{>}  \,|\, \isToken{=} ] \\
\end{align*}

\hypertarget{filtrage-et-motifs}{%
  \subsection{Filtrage et Motifs}\label{filtrage-et-motifs}}
\begin{align*}
  \grammarRule{MatchCase}  \quad ::=  \quad & |\quad  \grammarRule{Pattern} \isToken{->}  \grammarRule{Expr}               \\
                                            & |\quad \grammarRule{MatchCase} \isToken{|} \grammarRule{MatchCase}           \\
  \\
  \grammarRule{Pattern} \quad ::=  \quad    & |\quad \grammarRule{Litteral}                                                \\
                                            & |\quad \grammarRule{Id}                                                      \\
                                            & |\quad \grammarRule{ConstructeurId} \; \nTime{\grammarRuleUnSpaced{Pattern}} \\
\end{align*}


\hypertarget{types-1}{%
  \subsection{Types}\label{types-1}}

\begin{align*}
  \grammarRule{Type}    \quad ::=  \quad & |\quad \grammarRule{Vartype}                              \\
                                         & |\quad \grammarRule{Id}                                   \\
                                         & |\quad \nPlus{\grammarRuleUnSpaced{Type}}                 \\
                                         & |\quad \grammarRule{Type} \isToken{->} \grammarRule{Type} \\
\end{align*}

\hypertarget{semantique-de-traduction}{%
  \section{Semantique de traduction}\label{semantique-de-traduction}}

\newcommand{\translateNode}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\translateResult}[1]{\llbracket #1 \rrbracket}
\newcommand{\isElemMiniML}[1]{\textcolor{Maroon}{#1}}
\newcommand{\isElemLCBPV}[1]{\textcolor{ForestGreen}{#1}}
\newcommand{\Tab}{\quad \quad \quad \quad \quad \quad \;}
\hypertarget{notation}{%
  \subsection{Notation}\label{notation}}
$ \translateNode{\isElemMiniML{Tuple}(e_1 e_2)}{Expr}  \rightarrow \isElemLCBPV{Tuple} (\translateResult{e_1}\translateResult{e_2})$
\begin{itemize}
  \tightlist
  \item
        $\translateNode{\_}{Expr}  \rightarrow $ est la traduction d'un noeud expr du langage MiniML vers le langage LCBPV
  \item
        En \isElemMiniML{Marron} les elements propre au langage MiniML
  \item
        En \isElemLCBPV{Vert} les elements propre au langage LCBPV
  \item
        $X_n$ est le n-ième sous-noeud de l'arbre de syntaxe abstrait \newline
        Selon les cas $X$ peut être :
        \begin{itemize}
          \tightlist
          \item
                $e$ pour les expressions
          \item
                $p$ pour les motifs
          \item
                $t$ pour les types
          \item
                $d$ pour les définitions
                \begin{itemize}
                  \tightlist
                  \item
                        $dc$ pour les définitions de constructeurs
                \end{itemize}
          \item
                $v$ pour les identificateurs
          \item
                $i$ pour les entiers
          \item
                $b$ pour les booléens
        \end{itemize}
  \item
        $X_1 \dots X_n$ est la liste des sous-noeuds de type $X$ allant de $1$ à $n$
\end{itemize}

\hypertarget{programmes-1}{%
  \subsection{Programmes}\label{programmes-1}}

Un programme MiniML est une suite de taille arbitraire de définitions suivie d'une expression.
La sémantique de LCBPV ne permettant pas de définir des variables globales comme en MiniML il est nécessaire de transformer le programme en une seule expression.

On définit l'operation de traduction \(\translateNode{\_}{Prog}\) selon les cas de construction
des définitions précisées par la règle de grammaire : \grammarRule{Prog}

\begin{align*}
  \translateNode{\isElemMiniML{Prog}(d_1 \dots d_n \, e)}{Prog} \rightarrow \isElemLCBPV{Prog} (\translateResult{d_1 \dots d_n}\,\isElemLCBPV{Do}(\translateResult{e}))
\end{align*}

\pagebreak

\subsection{Définitions}\label{def}

On définit l'operation de traduction \(\translateNode{\_}{Def}\) selon les cas de construction
des définitions précisées par la règle de grammaire : \grammarRule{Def}

On distingue deux noeuds de types \grammarRule{Def}:
\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Variables Globales},
  \item
        Les définitions de \textbf{Types}.
\end{itemize}
\begin{align*}
  \text{(VARDEF)}  \quad & \translateNode{\isElemMiniML{VarDef}(v \; e)}{Def} \rightarrow   \isElemLCBPV{InsLet}(v, \translateResult{e})                                                   \\
  \\
  \text{(TYPDEF) } \quad & \translateNode{\isElemMiniML{TypeDef}(v \; t_1 \dots t_N \; c_1 \dots c_N)}{Def}                                                                                \\
  \rightarrow \;         & \isElemLCBPV{TypDef}(v \, \translateResult{t_1 \dots t_N} \, \isElemLCBPV{DefDatatype}( \translateResult{c_1  \dots  c_N}))
\end{align*}
\subsection{Types}\label{types-2}

On définit l'operation de traduction \(\translateNode{\_}{Type}\) selon les cas de construction
des types précisées par la règle de grammaire : \grammarRule{Type}

On distingue 3 noeuds de types $Type$:
\begin{itemize}
  \tightlist
  \item
        Les \textbf{Variables de type}.
  \item
        Les \textbf{Applications de types}.
  \item
        Les \textbf{Lambda}
\end{itemize}
\begin{align*}
  \text{(TVAR) }  & \translateNode{\isElemMiniML{TypeVar}(v)}{Type}  \rightarrow \isElemLCBPV{TypVar}(v)                                                                                       \\
  \\
  \text{(TAPP) }  & \translateNode{\isElemMiniML{TypeConstructor}(v \; t_1 \, \dots \,t_N)}{Type} \rightarrow  \isElemLCBPV{TypApp}(v\; \translateResult{t_1 \dots t_N}) \\
  \\
  \text{(TCLOS) } & \translateNode{\isElemMiniML{TypeLambda}(t_1\,t_2) }{Type}                                                                                                                 \\
  \rightarrow \;  & \isElemLCBPV{TypClosure}(                                                                                                                                                  \\
                  & \Tab \isElemLCBPV{Exp}                                                                                                                                                     \\
                  & \Tab \isElemLCBPV{TypFun}(\translateResult{t_1} \; \isElemLCBPV{TypThunk}(\translateResult{t_2}))                                                                          \\
  )
\end{align*}

\pagebreak
\subsection{Expressions}\label{exprs}

On définit l'operation de traduction \(\translateNode{\_}{Expr}\) selon les cas de construction
des expressions précisées par la règle de grammaire : \grammarRule{Expr}

On distingue 8 noeuds de types $Expr$: \begin{itemize}
  \tightlist
  \item
        Les \textbf{Litteraux}.
  \item
        Les \textbf{Variables}.
  \item
        Les \textbf{Appels de fonctions}.
  \item
        Les \textbf{Fixation}.
  \item
        Les \textbf{Lambda}.
  \item
        Les \textbf{Fonctions Recursive}.
  \item
        Les \textbf{Constructions}.
  \item
        Les \textbf{Correspondance de modèle}.
\end{itemize}
\begin{align*}
  \text{(INT)} \quad       & \translateNode{\isElemMiniML{Integer}(i)}{Expr} \rightarrow \isElemLCBPV{ExprInteger}(i)                                                                                                        \\
  \text{(BOOL)} \quad      & \translateNode{\isElemMiniML{Boolean}(b)}{Expr} \rightarrow \isElemLCBPV{ExprConstructor}(b)                                                                                                    \\
  \text{(UNIT)} \quad      & \translateNode{\isElemMiniML{Unit}}{Expr} \rightarrow \isElemLCBPV{ExprConstructor}(\isElemLCBPV{Unit})                                                                                         \\
  \\
  \text{(VAR)} \quad       & \translateNode{\isElemMiniML{Variable}(v)}{Expr} \rightarrow \isElemLCBPV{ExprVar}(v)                                                                                                           \\
  \text{(LAMBDA)} \quad    & \translateNode{\isElemMiniML{Lambda}(v \, e)}{Expr}                                                                                                                                             \\
  \rightarrow  \;          & \isElemLCBPV{ExprClosure}(                                                                                                                                                                      \\
                           & \Tab \isElemLCBPV{Exp}                                                                                                                                                                          \\
                           & \Tab \isElemLCBPV{ExprGet}(\; \isElemLCBPV{GetPatTag} \; (\isElemLCBPV{Call}\; v \; ExprThunk(\translateResult{e}))\;)                                                                          \\
  )                                                                                                                                                                                                                          \\
  \text{(FUN REC)} \quad   & \translateNode{\isElemMiniML{FonctionRec}(v_1 \, v_2\, e)}{Expr}                                                                                                                                \\
  \rightarrow  \;          & \isElemLCBPV{ExprClosure}(                                                                                                                                                                      \\
                           & \Tab \isElemLCBPV{Exp}                                                                                                                                                                          \\
                           & \Tab \isElemLCBPV{ExprRec}(v_1                                                                                                                                                                  \\
                           & \Tab \Tab \isElemLCBPV{ExprGet}(\; \isElemLCBPV{GetPatTag} \; (\isElemLCBPV{Call}\; v_2 \; ExprThunk(\translateResult{e}))\;)                                                                   \\
                           & \Tab)                                                                                                                                                                                           \\
                           & )                                                                                                                                                                                               \\
  \text{(CALL)} \quad      & \translateNode{\isElemMiniML{Call}(e_1 e_2)}{Expr}                                                                                                                                              \\
  \rightarrow      \;      & \isElemLCBPV{ExprBlock}(                                                                                                                                                                        \\
                           & \Tab \isElemLCBPV{InsOpen}(v_1 \; \isElemLCBPV{Exp} \; \translateResult{e_1} )                                                                                                                  \\
                           & \Tab \isElemLCBPV{InsForce}\;( v_2 \; \isElemLCBPV{ExprMethod}(\; \isElemLCBPV{Call} \; \isElemLCBPV{ExprVar}(v_1) \; \translateResult{e_2}\;)\;)                                               \\
                           & \Tab \isElemLCBPV{ExprVar}(v_2)                                                                                                                                                                 \\
  )                                                                                                                                                                                                                          \\
  \text{(BIND)} \quad      & \translateNode{\isElemMiniML{Binding}(v \, e_1 e_2)}{Expr}                                                                                                                                      \\
  \rightarrow  \;          & \isElemLCBPV{ExprBlock}(                                                                                                                                                                        \\
                           & \Tab \isElemLCBPV{InsLet}(v \; \translateResult{e_1})                                                                                                                                           \\
                           & \Tab \translateResult{e_2}                                                                                                                                                                      \\
  )                                                                                                                                                                                                                          \\
  \\
  \text{(CONSTRUCT)} \quad & \translateNode{\isElemMiniML{Construct}(v \, e_1 \dots e_N)}{Expr}  \rightarrow \isElemLCBPV{ExprConstructor} (\isElemLCBPV{ConsNamed}(v) \, \translateResult{e_1 \dots e_N}) \\
  \text{(MATCH)} \quad     & \translateNode{\isElemMiniML{Match}(e \,p_1 \, \dots \, p_N)}{Expr} \rightarrow  \isElemLCBPV{ExprMatch}(\translateResult{e} \, \translateResult{p_1 \dots p_N} )             \\
\end{align*}
\subsection{Motifs et Filtrage}\label{motifs-et-filtrage}

\[ Case(p,e) \rightarrow \llbracket Case(p,e) \rrbracket_{Case} \rightarrow \alpha \]

On définit la relation \({Case}\) selon les cas de construction
des motif de correspondance. Les cas de construction des motif de
correspondance sont donnés par les clauses des règles syntaxiques. Un
motif de correspondance est dit traduisible si chacune de ses clauses
peut être traduite.
\begin{itemize}
  \tightlist
  \item
        \(p\) est un motif
  \item
        \(e\) est l'expression qui sera évaluée si le motif est vérifié
\end{itemize}
\begin{align*}
  \text{(PATTAG)} \quad & Case(ConstructorPattern((n,c)), e)
  \\ &\rightarrow  MatchPatTag(ConsNamed(n), \llbracket c \rrbracket_{Case}, \llbracket e \rrbracket_{Expr})        \\
  \\
  \text{(PATVAR)} \quad & Case(VarPattern(x), e, l)
  \rightarrow  MatchPatVar((x, l), \llbracket e \rrbracket_{Expr}, l)
\end{align*}

\end{document}
