% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  12pt,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Palatino}
  \setsansfont[]{Helvetica}
  \setmonofont[]{Menlo}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin = 1.2in]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
\ifPDFTeX
\else
\babelfont[french]{rm}[]{Palatino}
\fi
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={MiniML Spec},
  pdfauthor={Fazazi Zeid; Luo Yukai; Dibassi Brahima},
  pdflang={fr},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={NavyBlue},
  pdfcreator={LaTeX via pandoc}}

\title{MiniML Spec}
\author{Fazazi Zeid \and Luo Yukai \and Dibassi Brahima}
\date{2023-05-06}

\begin{document}
\maketitle

\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\allowdisplaybreaks
\pagebreak

\hypertarget{syntaxe-miniml}{%
  \section{Syntaxe MiniML}\label{syntaxe-miniml}}

\hypertarget{jetons-de-lexing}{%
  \subsection{Jetons de lexing}\label{jetons-de-lexing}}

\hypertarget{suxe9parateurs}{%
  \subsubsection{Séparateurs}\label{suxe9parateurs}}

\[\{\quad\}\qquad[\quad]\qquad(\quad)\qquad;\qquad,\qquad*\qquad\rightarrow\qquad|\qquad=\]

\hypertarget{mots-clefs}{%
  \subsubsection{Mots Clefs}\label{mots-clefs}}

\[let \qquad fun\qquad in \qquad match \qquad with \qquad type \qquad of \qquad rec \qquad if \qquad then \qquad else\]

\hypertarget{types}{%
  \subsubsection{Types}\label{types}}

\[int\qquad bool\qquad unit\]

\hypertarget{operateurs}{%
  \subsubsection{Operateurs}\label{operateurs}}

\[ + \qquad - \qquad \% \qquad  /  \qquad :: \qquad  \&\& \qquad  || \qquad  * \qquad < \qquad > \qquad \leq \qquad \geq \qquad = \]

\hypertarget{valeurs-atomiques}{%
  \subsubsection{Valeurs Atomiques}\label{valeurs-atomiques}}

\begin{align*}
  integer & = (\;-\;)\;?\;[\;0\;-\;9\;]\* \\
  boolean & = (\;true\;|\;false\;)
\end{align*}

\hypertarget{identificateur}{%
  \subsubsection{Identificateur}\label{identificateur}}

\begin{align*}
  alphanum              & = [a-z \quad A-Z \quad 0-9 \quad \_]\,* \\
  basic\_ident          & = [a-z \quad \_] \, alphanum            \\
  vartype               & = [`a] \; [0 \, .. \, 9]\,*\            \\
  \\
  constructeur\_ident   & = [A-Z] \, alphanum                     \\
  constructeur\_infixes & = [:: \quad ,]
\end{align*}

\pagebreak

\hypertarget{grammaire}{%
  \subsection{Grammaire}\label{grammaire}}

Voici la grammaire BNF de notre langage MiniML.

\hypertarget{outils-de-lecture}{%
  \subsubsection{Outils de lecture}\label{outils-de-lecture}}

Pour simplifier la lecture de la grammaire, nous avons utilisé les
notations suivantes :

\begin{itemize}
  \tightlist
  \item
        \(\bf{Litteral}\) : Utilisation d'une règle définie
  \item
        \(basic\_ident_{\bf{list}}\) : Utilisation de la règle zéro ou
        plusieurs fois
  \item
        \textit{Variable} : Noeud ciblé par le cas
\end{itemize}

\hypertarget{programmes}{%
  \subsubsection{Programmes}\label{programmes}}

\begin{align*}
  \bf{Prog} := \quad & |\quad \bf{Def}                     \\
                     & |\quad \bf{Expr}                    \\
                     & |\quad \bf{Prog} \; ;; \; \bf{Prog}
\end{align*}

\hypertarget{definitions}{%
  \subsubsection{Definitions}\label{definitions}}

\begin{align*}
  \bf{Def} := \quad & |\quad let \; basic\_ident = \bf{Expr}                                                                        &  & \textit{Variable}       \\
                    & |\quad let \; basic\_ident_{\bf{list}} = \bf{Expr}                                                            &  & \textit{Fonction}       \\
                    & |\quad let \; rec \; basic\_ident_{\bf{list}} = \bf{Expr}                                                     &  & \textit{Fonction Rec}   \\
                    & |\quad type \; vartype_{\bf{list}} \; basic\_ident =  \bf{NewContructors}                                     &  & \textit{Type}           \\
                    & |\quad type \; vartype_{\bf{list}} \; basic\_ident \; with \; basic\_ident_{\bf{list}} =  \bf{NewContructors} &  & \textit{Type Parametré}
\end{align*} \begin{align*}
  \bf{NewContructors} :=   \quad       & |\quad  constructeur\_ident                                                            \\
                                       & |\quad  constructeur\_ident \;of\; \textbf{Type}                                       \\
                                       & |\quad  \textbf{NewContructors} \;'|'\; \textbf{NewContructors}                        \\
  \\
  \bf{NewContructorsParam} :=    \quad & |\quad constructeur\_ident \;of\; \textbf{Type} \; with \; \textbf{ParamEquation}      \\
                                       & |\quad  \textbf{NewContructorsParam} \;'|'\; \textbf{NewContructorsParam}         &  & \\
  \\
  \bf{ParamEquation} := \quad          & |\quad basic\_ident                                                                    \\
                                       & |\quad 0                                                                               \\
                                       & |\quad 1                                                                               \\
                                       & |\quad (\,\textbf{ParamEquation}\,)                                                    \\
                                       & |\quad \textbf{ParamEquation} \; + \; \textbf{ParamEquation}                           \\
                                       & |\quad \textbf{ParamEquation} \; * \; \textbf{ParamEquation}                           \\
\end{align*}

\hypertarget{expressions}{%
  \subsubsection{Expressions}\label{expressions}}

\begin{align*}
  \bf{Litteral}  \quad :=  \quad       & |\quad integer                                                                                                                       \\
                                       & |\quad boolean                                                                                                                       \\
                                       & |\quad (\;)                                                                                          &  & \textit{ Unit}             \\
  \\
  \bf{Expr}  \quad :=  \quad           & |\quad ( \textbf{Expr} )                                                                                                             \\
                                       & |\quad \textbf{Litteral}                                                                                                             \\
                                       & |\quad basic\_ident                                                                                                                  \\
                                       & |\quad \textbf{UnaryOperator}\quad \textbf{Expr}                                                                                     \\
                                       & |\quad \textbf{Expr}\quad \textbf{BinaryOperator}\quad \textbf{Expr}                                                                 \\
                                       & |\quad \textbf{Expr}\quad \textbf{Expr}                                                              &  & \textit{ Call}             \\
                                       & |\quad \textbf{Expr};\textbf{Expr}                                                                   &  & \textit{ Sequence }        \\
                                       & |\quad let \; basic\_ident = \textbf{Expr}\; in \; \textbf{Expr}                                     &  & \textit{ Binding}          \\
                                       & |\quad fun \; basic\_ident_{\bf{list}} \rightarrow  \textbf{Expr}                                    &  & \textit{ Lambda}           \\
                                       & |\quad \textbf{Expr}\; constructeur\_infixes\; \textbf{Expr}                                                                         \\
                                       & |\quad constructeur\_ident  \; \textbf{Expr}\;                                                       &  & \textit{Construction}      \\
                                       & |\quad constructeur\_ident                                                                                                           \\
                                       & |\quad let \; basic\_ident_{\bf{list}} = \textbf{Expr}\; in \; \textbf{Expr}                         &  & \textit{Fonction}          \\
                                       & |\quad let \; rec \; basic\_ident \; basic\_ident_{\bf{list}} = \textbf{Expr}\; in \;\textbf{Expr}\; &  & \textit{Fonction Recusive} \\
                                       & |\quad match \; \textbf{Expr}\; with \; \textbf{Match\_Case}\quad                                                                    \\
                                       & |\quad if \; \textbf{Expr}\; then \; \textbf{Expr}\; else \; \textbf{Expr}                                                           \\
  \\
  \bf{UnaryOperator}  \quad :=  \quad  & |\quad  not                                                                                                                          \\
  \bf{BinaryOperator}  \quad :=  \quad & |\quad \&\&                                                                                                                          \\
                                       & |\quad ||                                                                                                                            \\
                                       & |\quad +                                                                                                                             \\
                                       & |\quad -                                                                                                                             \\
                                       & |\quad /                                                                                                                             \\
                                       & |\quad \%                                                                                                                            \\
                                       & |\quad *                                                                                                                             \\
                                       & |\quad <                                                                                                                             \\
                                       & |\quad >                                                                                                                             \\
                                       & |\quad \leq                                                                                                                          \\
                                       & |\quad \geq                                                                                                                          \\
                                       & |\quad =                                                                                                                             \\
\end{align*}

\hypertarget{filtrage-et-motifs}{%
  \subsubsection{Filtrage et Motifs}\label{filtrage-et-motifs}}

\begin{align*}
  \bf{Match\_Case}  \quad :=  \quad & |\quad  \textbf{Pattern} \rightarrow  \textbf{Expr}                         \\
                                    & |\quad \textbf{Pattern} \rightarrow  \textbf{Expr}\; '|'\; \bf{Match\_Case} \\
  \\
  \textbf{Pattern} \quad :=  \quad  & |\quad   ( \textbf{Pattern} )                                               \\
                                    & |\quad \textbf{Litteral}                                                    \\
                                    & |\quad basic\_ident                                                         \\
                                    & |\quad \_                                                                   \\
                                    & |\quad constructeur\_ident                                                  \\
                                    & |\quad constructeur\_ident \; \textbf{Pattern}                              \\
\end{align*}

\hypertarget{types-1}{%
  \subsubsection{Types}\label{types-1}}

\begin{align*}
  \textbf{Type}    \quad :=  \quad & |\quad  (\textbf{Type})                                                    \\
                                   & |\quad int                                                                 \\
                                   & |\quad bool                                                                \\
                                   & |\quad unit                                                                \\
                                   & |\quad \textbf{Type} * \textbf{Type}            &  & \textit{Tuple Type}   \\
                                   & |\quad \textbf{Type} \rightarrow  \textbf{Type} &  & \textit{Lambda Type}  \\
                                   & |\quad vartype                                  &  & \textit{'a}           \\
                                   & |\quad basic\_ident                             &  & \textit{Defined Type} \\
                                   & |\quad \textbf{Type}_{\bf{List}}                &  & \textit{App Type}     \\
\end{align*} \newpage

\hypertarget{semantique-de-traduction}{%
  \section{Semantique de traduction}\label{semantique-de-traduction}}

\hypertarget{programmes-1}{%
  \subsection{Programmes}\label{programmes-1}}

\[ \vdash_{Prog} Prog[cs] \rightarrow Prog'(x) \] Un programme MiniML
est une suite de commandes \([cs]\) qui est traduite en un programme
\(x\) en LCBPV. Un programme est dit traduisible si la suite de
commandes \([cs]\) qui le compose peut-être traduite.

\begin{align*}
  \text{ si }    & \vdash_{\text{Cmds}} cs \rightarrow  (g,\omega,\upsilon)                \\
  \text{  alors} & \vdash_{\text{Cmds}} Prog[cs] \rightarrow  Prog'(\omega;Do(g,\upsilon))
\end{align*}

\hypertarget{suites-de-commandes}{%
  \subsection{Suites de commandes}\label{suites-de-commandes}}

\[ \vdash_{\text{Cmds}} cs \rightarrow (\gamma,\omega,\upsilon) \] Le
resultat de la traduction d'une suite de commandes \(cs\) est un triplet
\((\gamma,\omega,\upsilon)\) où:

\begin{itemize}
  \tightlist
  \item
        \(\gamma\) est le resultat de la traduction des variables globales,
  \item
        \(\omega\) est le resultat de la traduction des definitions de types
  \item
        \(\upsilon\) est la dernière expression traduite.
\end{itemize}

Ce triplet est rendu nécessaire par la sémantique de LCBPV qui ne permet
pas de définir des variables globales comme en MiniML. Cela a aussi pour
conséquence un changement de portée entre les déclarations de type en
MiniML et en LCBPV.

\begin{align*}
  \text{(VAR DEFS)  si }        & \; d  \in DEF,                                                               \\
  \text{et si }                 & \vdash_{\text{Cmds}} cs \rightarrow (\gamma,\omega,\upsilon)                 \\
  \text{et si }                 & \vdash_{\text{Def}} d \rightarrow  \pi                                       \\
  \text{et si }                 & \pi \in GLB                                                                  \\
  alors                         & \vdash_{\text{Cmds}} (Def(d); cs) \rightarrow ((\gamma;\pi),\omega,\upsilon) \\
  \\
  \text{(TYPE DEFS)  si }       & \; d  \in DEF,                                                               \\
  \text{et si }                 & \vdash_{\text{Cmds}} cs \rightarrow (\gamma,\omega,\upsilon)                 \\
  \text{et si }                 & \vdash_{\text{Def}} d \rightarrow  \pi                                       \\
  \text{et si }                 & \pi \in TYPE                                                                 \\
  alors                         & \vdash_{\text{Cmds}} (Def(d); cs) \rightarrow (\gamma,(\omega;\pi),\upsilon) \\
  \\
  \\
  \text{(GLB EXPR)} \text{ si } & b  \in EXPR,                                                                 \\
  \text{et si }                 & \vdash_{\text{Cmds}} cs \rightarrow (\gamma,\omega,\upsilon)                 \\
  \text{et si }                 & \vdash_{\text{Expr}} b \rightarrow  \upsilon'                                \\
  alors                         & \vdash_{\text{Cmds}} (Expr(b), cs) \rightarrow  (\gamma,\omega,\upsilon')
\end{align*}

\hypertarget{duxe9finitions}{%
  \subsection{Définitions}\label{duxe9finitions}}

\[ \vdash_{\text{Def}} d \rightarrow \pi \] On définit la relation
\(Def\) selon les cas de construction des définitions. Les cas de
construction des définitions sont donnés par les clauses des règles
syntaxiques.

Une définition est dite traduisible si chacune de ses clauses peut être
traduite. On distingue deux catégories de définitions:

\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Variables Globales},
  \item
        Les définitions de \textbf{Types}.
\end{itemize}

Ces deux catégories de définitions sont traitées différemment par le
jugement \(\vdash_{\text{Cmds}}\)

\begin{itemize}
  \tightlist
  \item
        \(\pi\) est donc la traduction de la définition \(d\) placée dans la
        bonne catégorie.
\end{itemize}

\begin{align*}
  \text{(VARDEF)}
  \text{ si }                 & \vdash_{\text{Expr}} e \rightarrow  e'                                \\
  \text{alors}                & \vdash_{\text{Def}} VariableDef(v, e) \rightarrow  GLB(InsLet(v, e')) \\
  \\
  \text{(TYPDEF)} \text{ si } & \vdash c1 \rightarrow  c1'
  \dots \text{ si } \vdash cN \rightarrow  cN'                                                        \\
  \text{alors}                & \vdash_{\text{Def}} TypeDef(n, [t1,\dots,tn], [c1,\dots,cN])          \\
  \rightarrow \;              & \text{TYPE}(TypDef(n, [t1,\dots,tn], DefDatatype[c1',\dots,cN']))     \\
\end{align*}

\hypertarget{types-2}{%
  \subsection{Types}\label{types-2}}

\[ \vdash_{\text{Type}} t \rightarrow t' \] On définit la relation
\(\vdash_{Type}\) selon les cas de construction des types. Les cas de
construction des types sont donnés par les clauses des règles
syntaxiques. Un type est dit traduisible si chacune de ses clauses peut
être traduite.

\begin{align*}
  \text{(TINT)}               & \vdash_{Type} TypeInt \rightarrow  TypInt                                               \\
  \text{(TBOOL)}              & \vdash_{Type} TypeBool \rightarrow  TypBool                                             \\
  \text{(TUNIT)}              & \vdash_{Type} TypeUnit \rightarrow  TypUnit                                             \\
  \text{(TDEF)}               & \vdash_{Type} TypeDefined(id) \rightarrow  TypVar(id)                                   \\
  \text{(TVAR)}               & \vdash_{Type} TypeVar(id) \rightarrow  TypVar (id)                                      \\
  \\
  \text{(TTUPLE)} \text{ si } & \vdash_{Type} t1 \rightarrow  t_1,\dots \text{ et }  \vdash_{Type} tN \rightarrow  t_N  \\
  \text{alors}                & \vdash_{Type} TypeTuple([t1,\dots, tN]) \rightarrow  TypTuple[t_1,\dots,t_N]            \\
  \\
  \text{(TCONS)} \text{ si }  & \vdash_{Type} t \rightarrow  t'                                                         \\
  \text{ si }                 & \vdash_{Type} p1 \rightarrow  p_1,\dots \text{ et } \vdash_{Type} pN \rightarrow  p_N   \\
  \text{alors}                & \vdash_{Type} TypeConstructor(t, [p1,\dots,pN]) \rightarrow  TypApp(t, [p_1,\dots,p_N]) \\
  \\
  \\
  \text{(TLAMB)} \text{ si }  & \vdash_{Type} a \rightarrow  a'                                                         \\
  \text{et si}                & \vdash_{Type} ret  \rightarrow  ret'                                                    \\
  \text{alors}                & \vdash_{Type} TypeLambda(a,ret)                                                         \\
  \rightarrow \;              & TypClosure(Exp, \, (TypFun(TypThunk(ret'), a')))
\end{align*}

\hypertarget{litteraux-et-expressions}{%
  \subsection{Litteraux et Expressions}\label{litteraux-et-expressions}}

\[ \vdash_{\text{Expr}} e \rightarrow e' \]

On définit la relation \(\vdash_{Expr}\) selon les cas de construction
des expr. Les cas de construction des expressions sont donnés par les
clauses des règles syntaxiques. Une expression est dite traduisible si
chacune de ses clauses peut être traduite. \begin{align*}
  \text{(INT)} \text{ si }     & i  \in \text{NUM}                                                                                                       \\
  \text{alors}                 & \vdash_{Expr} Integer(i) \rightarrow  ExprInt(i)                                                                        \\
  \text{(TRUE)} \quad          & \vdash_{Expr} Boolean(true) \rightarrow  ExprConstructor(True,[\;])                                                     \\
  \text{(FALSE)} \quad         & \vdash_{Expr} Boolean(false) \rightarrow  ExprConstructor(False, [\;])                                                  \\
  \text{(UNIT)}\quad           & \vdash_{Expr} Unit \rightarrow  ExprConstructor(Unit, [\;])
  \\
  \\
  \text{(TUPLE)} \text{ si }   & \vdash_{Expr} e1 \rightarrow  e_1, \dots \text{ si }  \vdash_{Expr} eN \rightarrow  e_N                                 \\
  \text{alors}                 & \vdash_{Expr} Tuple([e1,\dots,eN]) \rightarrow  ExprConstructor(Tuple, [e_1,\dots,e_N])
  \\
  \\
  \text{(UNARY1)} \text{ si }  & \vdash_{Expr} a \rightarrow  a'                                                                                         \\
  \text{alors}                 & \vdash_{Expr} CallUnary(op, [a]) \rightarrow  ExprMonPrim(op, a')                                                       \\
  \text{(UNARY0)} \text{ si }  & \vdash_{Expr} Lambda(a,CallUnary(op, [a])) \rightarrow  \omega                                                          \\
  \text{alors}                 & \vdash_{Expr} CallUnary(op, [\;]) \rightarrow \omega                                                                    \\
  \\
  \\
  \text{(BINARY2)} \text{ si } & \vdash_{Expr} a1 \rightarrow  a_1 \text{ et }  \vdash_{Expr} a2 \rightarrow  a_2                                        \\
  \text{alors}                 & \vdash_{Expr} CallBinary(op, [a1:a2]) \rightarrow  ExprBinPrim(op, a_1, a_2)                                            \\
  \text{(BINARY1)}
  \text{ si }                  & \vdash_{Expr} Lambda(b,CallUnary(op, [a,b])) \rightarrow  \omega                                                        \\
  \text{alors}                 & \vdash_{Expr} CallBinary(op, [a]) \rightarrow \omega                                                                    \\
  \text{(BINARY0)}
  \text{ si }                  & \vdash_{Expr} Lambda(a,Lambda(b,CallUnary(op, [a,b]))) \rightarrow  \omega                                              \\
  \text{alors}                 & \vdash_{Expr} CallBinary(op, [\;]) \rightarrow \omega                                                                   \\
  \\
  \text{(CONSTR)} \text{ si }  & \vdash_{Expr} e \rightarrow  e'                                                                                         \\
  \text{alors}                 & \vdash_{Expr} Construct(c,e) \rightarrow  ExprConstructor(ConsNamed(c), e')                                             \\
  \\
  \text{(BIND)} \text{ si }    & \vdash_{Expr} i \rightarrow  i'                                                                                         \\
  \text{et si }                & \vdash_{Expr} c \rightarrow  c'                                                                                         \\
  \text{alors}                 & \vdash_{Expr} Binding(v,i,c) \rightarrow  ExprBlock(Blk([InsLet (v, i')], c'))                                          \\
  \\
  \text{(MATCH)} \text{ si }   & \vdash_{Expr} m \rightarrow  m'                                                                                         \\
  \text{ si }                  & m1  \in CASE \dots \text{ et } mN  \in CASE                                                                             \\
  \text{ si }                  & \vdash_{Case} m1 \rightarrow  m_1, \dots \text{ et } \vdash_{Case} mN \rightarrow  m_N                                  \\
  \text{alors}                 & \vdash_{Expr} Match(m,[m1,\dots,mN]) \rightarrow  ExprMatch(m', [m_1,\dots,m_N])                                        \\
  \\
  \text{(SEQ)} \text{ si }     & \vdash_{Expr} e1 \rightarrow  InsLet(x1, e_1), \dots \text{ et }  \vdash_{Expr} eN-1 \rightarrow  InsLet(xN-1, e_{N-1}) \\
  \text{et si }                & \vdash_{Expr} eN \rightarrow  e_N                                                                                       \\
  \text{alors}                 & \vdash_{Expr} Sequence([e1,\dots,eN])                                                                                   \\
                               & \rightarrow  ExprBlock(Blk([InsLet(x1, e_1); \dots ; InsLet(xN-1, e_{N-1})], e_N))                                      \\
  \\
  \text{(CALL)} \text{ si }    & \vdash_{Expr} a \rightarrow  a'                                                                                         \\
  \text{et si }                & \vdash_{Expr} f \rightarrow  f'                                                                                         \\
  \text{alors}                 & \vdash_{Expr} Call(f, a)                                                                                                \\
                               & \rightarrow  ExprBlock(Blk([InsOpen(Exp, f'), InsForce(ExprMethod(Call, [a']))]))                                       \\
  \\
  \text{(LAMBDA)} \text{ si }  & \vdash_{Expr} a \rightarrow  a'                                                                                         \\
  \text{et si }                & \vdash_{Expr} b \rightarrow  b'                                                                                         \\
  \text{alors}                 & \vdash_{Expr} Lambda(a, b)                                                                                              \\
                               & \rightarrow  ExprClosure(Exp, ExprGet([GetPatTag(Call, [a'], ExprThunk(b'))]))                                          \\
  \\
  \text{(REC)}
  \text{ si }                  & \vdash_{Expr} a \rightarrow  a'                                                                                         \\
  \text{ si }                  & \vdash_{Expr} v \rightarrow  v' \text{ et } \text{ si }  \vdash_{Expr} b \rightarrow  b'                                \\
  \text{alors}                 & \vdash_{Expr} FunctionRec(v, a, b)                                                                                      \\
                               & \rightarrow  ExprClosure(Exp,ExprRec(v',ExprGet([GetPatTag(Call, [a'], ExprThunk(b'))])))                               \\
\end{align*}

\hypertarget{motifs-et-filtrage}{%
  \subsection{Motifs et Filtrage}\label{motifs-et-filtrage}}

\[ \vdash_{\text{Case}} Case(p,e) \rightarrow \alpha \]

On définit la relation \(\vdash_{Case}\) selon les cas de construction
des motif de correspondance. Les cas de construction des motif de
correspondance sont donnés par les clauses des règles syntaxiques. Un
motif de correspondance est dit traduisible si chacune de ses clauses
peut être traduite.

\begin{itemize}
  \tightlist
  \item
        \(p\) est un motif
  \item
        \(e\) est l'expression qui sera évaluée si le motif est vérifié
\end{itemize}

\begin{align*}
  \text{(INTPAT)} \text{ si }  & l \in \text{NUM} \text{ et }  \vdash_{Expr} e \rightarrow  e'                      \\
  \text{alors}                 & \vdash_{Case} Case(LitteralPattern(l), e) \rightarrow
  MatchPatTag(IntLitt\; l, [\;], e')                                                                                \\
  \text{(BOOLPAT)} \text{ si } & l = Boolean(\_),                                                                   \\
  \text{ si }                  & \vdash l \rightarrow  l' \text{ et }  \vdash_{Expr} e \rightarrow  e'              \\
  \text{alors}                 & \vdash_{Case} Case(LitteralPattern(l), e)
  \rightarrow  MatchPatTag(l', [\;], e')                                                                            \\
  \text{(UNITPAT)} \text{ si } & l = Unit \text{ et }  \vdash_{Expr} e \rightarrow  e'                              \\
  \text{alors}                 & \vdash_{Case} Case(LitteralPattern(l), e) \rightarrow  MatchPatTag(Unit, [\;], e') \\
  \\
  \\
  \text{(TUPAT)}
  \text{ si }                  & p1  \in CASE,\dots \text{ si } pN  \in CASE                                        \\
  \text{ si }                  & \vdash p1 \rightarrow  p_1, \dots, \text{ si }  \vdash pN \rightarrow  p_N         \\
  \text{ et }                  & \vdash_{Expr} e \rightarrow  e'                                                    \\
  \text{alors}                 & \vdash_{Case} Case(TuplePattern([p1,\dots,pN]), e)
  \rightarrow  MatchPatTag(Tuple, [p_1,\dots,p_N], e')                                                              \\
  \\
  \text{(CONSPAT)}
  \text{ si }                  & c  \in CASE                                                                        \\
  \text{ si }                  & \vdash c \rightarrow  c'                                                           \\
  \text{ et }                  & \vdash_{Expr} e \rightarrow  e'                                                    \\
  \text{alors}                 & \vdash_{Case} Case(ConstructorPattern((n,c)), e)
  \rightarrow  MatchPatTag(ConsNamed(n), c', e')                                                                    \\
  \\
  \text{(VARPAT)} \text{ si }  & \vdash_{Expr} e \rightarrow  e'                                                    \\
  \text{alors}                 & \vdash_{Case} Case(VarPattern(x), e, l)
  \rightarrow  MatchPatVar((x, l), e', l)                                                                           \\
  \\
  \text{(WILDPAT)}
  \text{ si }                  & \vdash_{Expr} e \rightarrow  e'                                                    \\
  \text{alors}                 & \vdash_{Case} Case(WildcardPattern(), e, l)
  \rightarrow  MatchPatVar((n, l), e', l)
\end{align*}

\end{document}
