\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{array}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{abstract}
\usepackage{subfig}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{titlesec}           % Pour changer la tailles ses sections/subsections...
\usepackage{algorithmic}        % Pour manipuler les algorithmes
\usepackage{algorithm}          % Pour manipuler les algorithmes
% \usepackage{algpseudocode}
\usepackage[absolute,overlay]{textpos} % Pour bouger les figures
\usepackage[nottoc]{tocbibind} %Includes "References" in the table of contents

% Changement des commandes pour les algorithmes 
\renewcommand{\algorithmicrequire}{\textbf{Entrée(s)}}
\renewcommand{\algorithmicensure}{\textbf{Sortie(s)}}
\renewcommand{\algorithmicdo}{\textbf{faire}}
\renewcommand{\algorithmicforall}{\textbf{pour tout}}
\renewcommand{\algorithmicendfor}{\textbf{fin du pour}}
\renewcommand{\algorithmicif}{\textbf{si}}
\renewcommand{\algorithmicendif}{\textbf{fin du si}}
\renewcommand{\algorithmicthen}{\textbf{alors}}
\renewcommand{\algorithmicelse}{\textbf{sinon}}
\renewcommand{\algorithmicelsif}{\textbf{sinon si}}
\renewcommand{\algorithmiccomment}{\STATE //}
\setcounter{secnumdepth}{5}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%pour ecrire chiffres romains
\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother

\begin{document}

%régler l'espacement entre les lignes
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}


\titleformat{\chapter}{\bfseries\Large}{\arabic{chapter}.~}{0pt}{}   % Changer la taille des sections dans tout le document
\begin{titlepage}
\center % Center everything on the page

 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE Sorbonne Université}\\[1.5cm] % Name of your university/college
\textsc{\Large Rapport Final}\\[0.5cm] % Major heading such as course name
{\large 19 Mai 2023}\\ % Date, change the \today to a set date if you want to be precise
%\textsc{\large Minor Heading}\\[0.5cm] % Minor heading such as course title


%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\vspace{2cm}
\HRule \\[0.4cm]
{ \huge \bfseries Projet STL: \\ - \\ Interface pour Autobill}\\[0.7cm] % Title of your document
\HRule \\[1cm]


%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Auteurs:}\\
Brahima \textsc{Dibassi} \\
Zeid \textsc{Fazazi}\\
Yukai \textsc{Luo} 
\vspace{2.5cm}
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.55\textwidth}
\begin{flushright} \large
\emph{Encadrants:} \\
Hector \textsc{Suzanne}\\ % Supervisor's Name
Emmanuel \textsc{Chailloux}\\ % Supervisor's Name
\textsc{}

\vspace{2.5cm}
\end{flushright}
\end{minipage}\\[1cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
%John \textsc{Smith}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[scale=0.6]{images/logo.png}\\[1cm] % Include a department/university logo - this will require the graphicx package
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}
\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\newpage
\section{Contexte du projet}\label{contexte-du-projet}
\begin{figure}
  \centering
  \includegraphics[scale=0.55]{Figures/Schema_Autobill.png}
  \caption{Représentation simplifiée d'Autobill\label{fig1}}
\end{figure}
\subsection{Historique et définitions}\label{historique-et-duxe9finitions}

Dans le cadre de sa thèse sur l'analyse statique de la consommation
mémoire d'un programme, notre tuteur de projet, Hector Suzanne, membre de l'équipe APR du laboratoire LIP6, a développé \textbf{Autobill}. \\

L'analyse statique est un ensemble de méthodes formelles permettant de
mesurer et détecter automatiquement des comportements ou des erreurs dans un
programme en examinant son code source. Parmi les usages les plus courants 
de l'analyse statique, il y'a le débogage pour identifier des erreurs 
syntaxiques (fautes de frappe) ou l'usage de variables non déclarée ou 
non-initialisée par exemple. D'autres outils emploient des heuristiques et des règles pour répondre à des problématiques d'optimisation de code ou de fiabilité/sécurité. Ces analyseurs statiques sont conçus dans le but d'améliorer la maintenabilité du code. \\ 

Autobill s'intéresse particulièrement à l'occupation mémoire d'un programme. Historiquement, 
ce sujet de recherche a été plusieurs fois abordé dans divers travaux scientifiques, parmi eux, ceux de Jan Hoffmann et Steffen Jost sur l'analyse de consommation de ressources automatisé AARA
\protect\hyperlink{ref-Hoffmann}{{[}2{]}} (\emph{Automatic Amortized
Resource Analysis}).\\ 

Cette technique suit un ensemble de règles d'inférences : chaque trait du langage analysé est annoté par ses bornes mémoire et on peut déduire la consommation mémoire que ce trait va engendrer. Pour déterminer ces bornes, l'AARA s'aide de l'analyse amortie par méthode du potentiel. En effet, l'analyse amortie s'inscrit dans une suite d'opérations sur des structures de données dynamiques pour calculer la coût total de cette séquence. Avec la méthode du potentiel, on attribue un potentiel aux structures de données manipulées, ce qui va affecter le coût que va avoir une opération sur cette structure. L’application de ces règles d'inférence sur l'ensemble des expressions du programme fournit une estimation raisonnable de ses bornes mémoires.\\

Des langages de programmation expérimentaux ont vu le jour et ont implémenté cette analyse comme Resource Aware ML \protect\hyperlink{ref-RAML}{{[}3{]}}, un langage fonctionnel \emph{à la ML} créé par Jan Hoffmann, Klaus Aehlig et Martin Hofmann.

\hypertarget{quest-ce-quautobill}{%
  \subsection{Qu'est-ce qu'Autobill ?}\label{quest-ce-quautobill}}

La proposition d'Hector Suzanne avec Autobill se différencie par un
niveau d'analyse plus précis sur les fermetures et les arguments
fonctionnels d'un programme. D'abord, parmi les entrées possibles
illustrées sur la gauche de la figure \ref{fig1}, Autobill ne supporte
uniquement que des programmes écrits soit en modèle machine propre à
Autobill, soit en \textbf{Call-By-Push-Value} (CBPV)
\protect\hyperlink{ref-Levy}{{[}4{]}}, avec ou sans continuation
explicite. \\ 

Call-By-Push-Value est un langage qui utilise un paradigme déjà éprouvé,
décrit dans la thèse de Paul Blain Lévy
\protect\hyperlink{ref-Levy}{{[}4{]}}. Dans CBPV, toutes les valeurs et fonctions sont stockées dans une pile. Lorsqu'une fonction est appelée, ses arguments sont placés sur la pile avant que la fonction elle-même ne soit ajoutée à la pile. Ce mécanisme permet de suivre de manière explicite les quantités de mémoire pour chaque valeur introduite/éliminée ou fonction appelée/terminée. Aussi,
le langage permet d'exprimer clairement les stratégies d'évaluation utilisées dans le code source : soit en \textbf{\textit{call-by-value}}, en évaluant les arguments avant de lancer l'opération, soit en \textbf{\textit{call-by-name}}, en évaluant les arguments uniquement lorsqu’ils seront effectivement utilisés dans la fonction appelée. Ainsi, on fixe quand les évaluations se déroulent, afin de mieux prédire la consommation de mémoire à chaque
étape du programme. Ces traits uniques font de CBPV un langage de choix à analyser pour Autobill. \\

L'entrée est donc imposée. Ainsi, pour étendre l'usage d'Autobill à un
autre langage de programmation, un travail de traduction de ce langage
donné vers CBPV doit avoir lieu. Cela implique donc de comprendre le
langage que l'on compile, notamment les stratégies d'évaluations
implicites mises en œuvre, et de l'adapter aux caractéristiques uniques
de CBPV citées plus haut. \\ 

À partir d'une entrée en CBPV, Autobill traduit le programme en un code
machine avec continuations explicites, exprimant explicitement les
contraintes de taille qui s'appliquent sur l'entrée. Il l'internalise,
c'est à dire construit l'arbre syntaxique abstrait (AST) de ce
programme. Ensuite, Autobill infère dans l'AST le typage de ses
expressions ainsi que leurs polarités, pour démarquer les calculs et les
valeurs dans l'AST. Enfin, en sortie, on remarque dans la figure
\ref{fig1} la possibilité de tirer une interprétation du programme, mais
surtout de récupérer les contraintes dans un format MiniZinc
\protect\hyperlink{ref-minizinc}{{[}5{]}} ou Coq
\protect\hyperlink{ref-coq}{{[}6{]}}. Ce sont des outils des assistants
de preuve qui permettent, à l'aide d'un langage dédié, d'exprimer
explicitement des contraintes logiques. Autobill s'en sert pour décrire
les bornes mémoires nécessaires au fonctionnement d'un programme. On
peut alors traiter ces équations avec des solveurs, fournis aussi par
ces deux outils, pour prouver des propriétés de complexité temporelle ou
spatiale.
\newpage
\hypertarget{objectifs-du-projet}{%
  \subsection{Objectifs du projet}\label{objectifs-du-projet}}

Notre démarche se rapproche de celle de RAML
\protect\hyperlink{ref-RAML}{{[}3{]}} avec leur site officiel: offrir
une interface Homme-Machine accessible à tous et illustrant un sujet de
recherche en analyse statique.

Le sujet de notre projet STL va donc être de soutenir l'effort de
développement en proposant une interface sur le Web permettant la libre
manipulation de l'outil Autobill par des utilisateurs à travers un
environnement de développement sur navigateur. \newpage On souhaite
aussi faciliter l'utilisation de l'outil avec un langage fonctionnel pur
en entrée plus accessible, un \textbf{MiniML}. Cela nous contraint donc
à adapter cette nouvelle entrée pour qu'elle soit compatible avec
Autobill. Enfin, on se charge aussi de traiter les différentes sorties
standards et d'erreurs d'Autobill, notamment les expressions de
contraintes, afin de les passer à des solveurs externes, en tirer des
preuves de complexité et les afficher directement sur le client Web.

Par rapport à la chaîne d'instructions d'Autobill et à la Figure
\ref{fig1}, on se place donc en amont du code LCBPV en entrée et après
la sortie en code MiniZinc/Coq.

Notre charge de travail doit se diviser en plusieurs tâches principales:

\begin{itemize}
  \tightlist
  \item
        L'implémentation du langage MiniML et sa traduction vers CBPV
  \item
        La mise en place d'une interface Web
  \item
        La mise en relation entre l'interface Web et la machine Autobill
  \item
        Le traitement des contraintes d'Autobill par un solveur externe
  \item
        Les tests de performances et comparaisons avec les solutions
        existantes
\end{itemize}

\begin{figure}
  \centering
  \includegraphics{Figures/DiagrammeHautNiveauPSTL.png}
  \caption{Représentation du système cible}
\end{figure}

\hypertarget{processus-de-conception}{%
  \subsection{Processus de conception}\label{processus-de-conception}}

Lors de la conception de l'interface, les contraintes étaient multiples.
La première était l'interopérabilité des technologies du projet. En
effet \textbf{Autobill} étant développé en \textbf{OCaml}, il était
nécessaire de trouver des moyens pour l'adapter à un environnement Web.
La seconde était qu'il fallait développer cette interface en simultané
avec \textbf{Autobill} et ajuster notre travail en fonction des besoins
courants de nos encadrants. Mais la plus importante d'entre elles était
le souhait de nos encadrants que l'application soit principalement côté
client afin de simplifier son déploiement.

Une fois ces contraintes établies, nous avons dû, tout au long de ce
projet, effectuer des choix, que ce soit en matière de design ou de
technologies. Nous tenons donc à travers ce rapport à mettre en lumière
ces décisions, tout en décrivant le travail qu'elles ont engendré.

\newpage

\hypertarget{interface-web}{%
  \section{Interface web}\label{interface-web}}

Dans l'optique de ne pas se restreindre dans l'utilisation d'outils
notamment au niveau du solveur de contraintes, le groupe s'est orienté
vers deux structures de projets différentes et indépendantes: l'une
fonctionnant avec un client unique, la seconde avec un serveur dédié et
un client qui expose ce serveur.

L'avantage réside dans le fait que, lors du développement, si un nouvel
outil est amené à être utilisé mais ne dispose de compatibilité sur
navigateur Web, alors le serveur peut répondre à ce problème. C'est
aussi un sujet de comparaison intéressant à présenter par la suite, que
ce soit au niveau des performances que du déploiement de ces solutions.

De cette démarche, il en résulte un code source d'environ 500 lignes,
client et serveur compris, faisant tourner notre IDE en ligne dans un
état fonctionnel.

\hypertarget{client-uniquement}{%
  \subsection{Client uniquement}\label{client-uniquement}}

Une première approche tout client a été mise œuvre dès le début du
projet. Celle-ci permettait de garantir une facilité dans le déploiement
en ligne de notre solution. L'environnement limité du navigateur Web a
remis en question la tenue de cette architecture, mais des compromis ont
été trouvés pour satisfaire la contrainte d'interopérabilité entre le
Web et Ocaml.

\hypertarget{outils-et-technologies-utilisuxe9s}{%
  \subsubsection{Outils et technologies
    utilisés}\label{outils-et-technologies-utilisuxe9s}}

\begin{itemize}
  \item
        \textbf{HTML / CSS / Javascript (JS)}: Il s'agit de la suite de
        langages principaux permettant de bâtir l'interface Web souhaitée. On
        a ainsi la main sur la structure de la page à l'aide des balises HTML,
        du style souhaité pour l'éditeur de code avec le CSS et on vient
        apporter l'interactivité et les fonctionnalités en les programmant
        avec Javascript, complété par la librairie React.
  \item
        \textbf{React.js} \protect\hyperlink{ref-react}{{[}7{]}}: React.js est
        une bibliothèque JavaScript \emph{open-source} pour la création
        d'interfaces utilisateur,utilisée pour la création d'applications web
        modernes et interactives. Parmi les avantages de cette technologie, il
        y a l'utilisation du Virtual DOM (Document Object Model) qui permet
        une mise à jour plus efficace et rapide des éléments d'une page. Le
        Virtual DOM est une représentation virtuelle d'un arbre DOM qui est
        stockée en mémoire et mise à jour en temps réel en fonction des
        interactions de l'utilisateur avec l'interface. On modifie seulement
        les éléments impactés, et non l'ensemble du DOM de la page, ce qui se
        traduit par des temps de réponse plus rapides et des meilleures
        performances.\newline  Aussi, React est basé sur la programmation
        orientée composant. L'interface utilisateur est décomposée en petits
        composants réutilisables, chacun étant responsable de l'affichage
        d'une partie spécifique de l'interface. Chaque composant est construit
        de manière indépendante et peut être utilisé à plusieurs endroits dans
        une application. Cette approche modulaire rend l'interface plus
        flexible et maintenable. D'autres solutions concurrentes et valables
        telles que Angular.js \protect\hyperlink{ref-angularjs}{{[}8{]}} ou
        Vue.js \protect\hyperlink{ref-vuejs}{{[}9{]}} proposent une expérience
        développeur similaire.\newline  Néanmoins, ces dernières sont bien
        moins recherchées sur le marché du travail que React. Nous voulions à
        travers ce projet nous former et pratiquer une technologie très en
        vogue et que l'on pourra facilement réinvestir plus tard dans notre
        parcours professionnel.
  \item
        \textbf{CodeMirror} \protect\hyperlink{ref-codemirror}{{[}10{]}}:
        C'est une librairie Javascript permettant d'intégrer un éditeur de
        code puissant, incluant le support de la coloration syntaxique, de
        l'autocomplétion ou encore le surlignage d'erreurs. Les
        fonctionnalités de l'éditeur sont grandement extensives et permettant
        même la compatibilité avec un langage de programmation personnalisé
        comme MiniML. Enfin, CodeMirror est disponible sous licence MIT, libre
        de droits.
  \item
        \textbf{OCaml} \protect\hyperlink{ref-Minsky_Ocaml}{{[}11{]}}
        \protect\hyperlink{ref-chailloux}{{[}12{]}}
        \protect\hyperlink{ref-Leroy}{{[}13{]}} + \textbf{Js\_of\_OCaml}
        \protect\hyperlink{ref-js_of_ocaml}{{[}14{]}}: Afin de manipuler la
        librairie d'Autobill, il est nécessaire de passer par OCaml pour
        traiter le code en entrée et en sortir des équations à résoudre ou des
        résultats d'interprétations. Pour faire le pont entre Javascript et
        OCaml, on utilise Js\_of\_OCaml, une librairie contenant, entre
        autres, un compilateur qui transpile du bytecode OCaml en Javascript
        et propose une grande variété de primitive et de type pour manipuler
        des éléments Javascript depuis OCaml. L'API de Js\_of\_OCaml est
        suffisamment fournie pour développer entièrement des applications web
        complètes et fonctionnelles.\newline  Pour ce projet, il sert surtout
        pour interagir avec Autobill et la librairie de MiniML depuis le
        client Web. Dans un fichier \texttt{main.ml}, on exporte un objet
        Javascript contenant plusieurs méthodes correspondant chacune à un
        mode d'exécution différent d'Autobill. Chaque méthode prend en entrée
        le code MiniML à traiter et réalise les transformations nécessaires
        pour générer la sortie demandée.\newline  Néanmoins, en l'absence de
        sortie standard ou d'erreurs, les messages d'exceptions d'Ocaml, par
        exemple, n'apparaissent que dans la console Javascript du navigateur.
        Js\_of\_ocaml met à notre disposition un module \texttt{Sys\_js} qui
        offre des primitives permettant de capturer les possibles messages sur
        les sorties et les rediriger dans des buffers. Ces buffers peuvent
        être convertis en chaînes de caractères et retournés au client par la
        suite.\newline  La question s'est posée de l'intérêt de Js\_of\_OCaml
        comparé à d'autres technologies comme ReasonML
        \protect\hyperlink{ref-reasonml}{{[}15{]}} ou Rescript
        \protect\hyperlink{ref-rescript}{{[}16{]}}. En effet, ce sont tout
        deux des langages qui ont émergé d'Ocaml et permettent de créer dans
        un paradigme fonctionnel des applications web complexes. Des
        compilateurs pour transpiler du code Rescript (Bucklescript) ou
        ReasonML vers Javascript existent et ReasonML permet même de compiler
        vers du code en React.\newline  Néanmoins, notre objectif principal
        est la manipulation de la librairie d'Autobill ainsi que celle de
        MiniML depuis le Web. Ces deux technologies affichent des syntaxes
        différentes de celle d'OCaml, ce qui empêche toute compatibilité avec
        les bibliothèques d'OCaml. Js\_of\_OCaml en complément avec un client
        en React correspond donc à un bon compromis dans notre cas d'étude.
\end{itemize}

\newpage

\begin{itemize}
  \tightlist
  \item
        \textbf{MiniZinc} \protect\hyperlink{ref-minizinc}{{[}5{]}} : À la
        génération des expressions de contraintes, Autobill retourne une
        sortie au format MiniZinc. Ce langage permet de décrire des problèmes
        de manière déclarative à l'aide de contraintes logiques. L'objectif
        avec MiniZinc est de calculer les bornes mémoires minimums pour
        satisfaire les contraintes mémoires du programme et d'afficher, sous
        forme d'équation, le résultat dans la sortie de notre IDE. Son API
        prend en charge une large gamme de solveurs. Aussi, il dispose d'une
        grande communauté d'utilisateurs et de contributeurs, ce qui nous
        permet de trouver nombreuses ressources disponibles pour
        l'apprentissage et le dépannage.\newline  Sa librairie est codée en
        C++ mais il reste utilisable dans notre interface Web grâce à Web
        Assembly. C'est un format binaire de code exécutable qui permet de
        porter des applications codées dans des langages de programmation sur
        le Web. Grâce à des compilateurs vers Web Assembly, comme Emscripten
        pour C/C++, on peut lancer des tâches intensives de résolution de
        contraintes, depuis n'importe quel navigateur Web moderne.
\end{itemize}

\hypertarget{aperuxe7u-de-linterface-graphique}{%
  \subsubsection{Aperçu de l'interface
    graphique}\label{aperuxe7u-de-linterface-graphique}}

\begin{figure}
  \centering
  \includegraphics{Figures/screen.png}
  \caption{Aperçu de l'interface graphique}
\end{figure}

\newpage

\hypertarget{serveur-client}{%
  \subsection{Serveur + client}\label{serveur-client}}

Dans le stade actuel d'Autobill, une architecture avec un client seul
peut répondre aux exigences du projet STL. Néanmoins, Autobill évolue
constamment et rien ne garantit que ses itérations suivantes puissent
être supportées par notre solution. Dans l'optique de rendre notre
solution plus flexible et \emph{futureproof}, une nouvelle version de
notre interface, qui déporte les tâches complexes vers un serveur
distant, a été développée.

On a souhaité aussi adapter le client pour qu'il opère dans ces deux
architectures différentes. Ainsi, dans notre environnement de
développement, on peut facilement faire la bascule entre un mode de
fonctionnement local/synchrone et un mode distant/asynchrone.

\hypertarget{schuxe9ma-de-communication}{%
  \subsubsection{Schéma de
    communication}\label{schuxe9ma-de-communication}}

\begin{figure}
  \centering
  \includegraphics{Figures/Communication.png}
  \caption{Schéma de communication}
\end{figure}

\newpage

Dans notre architecture Client-Server, nous avons mis en place 2
services principaux en utilisant le protocole HTTP (voir Figure 4): la
transformation de code MiniML vers l'équation résultant de l'analyse
statique et l'exécution de code MiniZinc. Dans le premier service, le
client envoie le code LCBPV au serveur via une requête POST, le serveur
le convertit en équation et le renvoie au client. Dans le second
service, le client envoie le code de MiniZinc au serveur via une requête
POST. Le serveur passe le code à un solveur de MiniZinc et renvoie le
résultat au client.

\hypertarget{outils-et-technologies-utilisuxe9s-1}{%
  \subsubsection{Outils et technologies
    utilisés}\label{outils-et-technologies-utilisuxe9s-1}}

\begin{itemize}
  \item
        \textbf{Node.js} \protect\hyperlink{ref-Node_js}{{[}17{]}} : Node.js
        permet une gestion asynchrone des opérations entrantes, ce qui permet
        d'exécuter plusieurs opérations simultanément sans bloquer le fil
        d'exécution principal. Par exemple, si deux requêtes sont envoyées au
        serveur en même temps, elles seront gérées en parallèle par le
        serveur. Ainsi, grâce à cette gestion asynchrone, Node.js permet
        d'optimiser l'utilisation des ressources système en réduisant les
        temps d'attente et en évitant les blocages inutiles, ce qui peut
        augmenter l'efficacité et les performances du programme. En outre,
        NodeJS est également connu pour son excellent support de la gestion
        des entrées/sorties et du traitement de données en temps
        réel.\newline  De plus, la grande quantité de packages disponible sur
        NPM (le gestionnaire de packages de Node.js) permet de gagner beaucoup
        de temps de développement et de faciliter notre tâche. Par example, le
        module Child processes
        \protect\hyperlink{ref-Child_Processes}{{[}18{]}} nous permet
        d'exécuter le code MiniZinc en passant les commandes directement. Cela
        nous permet d'éviter les restrictions du côté tout-client au niveau du
        solveur de contraintes notamment. Enfin, un des avantages de Node.js
        est qu'il nous permet d'utiliser le même langage de programmation que
        le client. On s'évite ainsi les écueils autour de l'interopérabilité
        et de la compatibilité entre deux instances codées dans des langages
        différents.
  \item
        \textbf{Express.js} \protect\hyperlink{ref-Express_js}{{[}19{]}} :
        Express.js est une bibliothèque d'application web populaire basée sur
        la plateforme Node.js, utilisé pour construire des applications web et
        des API évolutives. Il fournit de nombreux middlewares, tels que
        morgan \protect\hyperlink{ref-morgan}{{[}20{]}} pour enregistrer les
        journaux de session HTTP et helmet
        \protect\hyperlink{ref-helmet}{{[}21{]}} pour garantir la sécurité.
        Avec Express.js, nous pouvons facilement ajouter des middlewares en
        utilisant directement \texttt{app.use()} sans avoir à les ajouter
        manuellement. De plus, Express.js dispose d'un puissant routeur qui
        permet aux développeurs de gérer facilement les routes et de
        construire des API REST de manière efficace. Par conséquent,
        l'utilisation d'Express.js rend la développement plus facile et plus
        efficace, et rend également le code plus concis. Donc il permet aux
        développeurs de créer facilement des applications web plus rapides et
        évolutives. Il dispose d'une plus grande communauté que les
        bibliothèques plus jeunes, avec de nombreuses ressources et solutions
        disponibles.
\end{itemize}

\newpage

\begin{itemize}
  \item
        \textbf{REST API} \protect\hyperlink{ref-PC3R}{{[}22{]}} : L'API REST
        est un modèle de conception d'interface de programmation d'application
        Web (API) utilisé pour fournir un accès aux ressources sur le Web. Il
        est basé sur le protocole HTTP et utilise des requêtes et des réponses
        HTTP pour communiquer. \newline  La conception de l'API REST est très
        simple. Elle utilise des verbes HTTP (GET, POST, PUT, DELETE, etc.)
        pour représenter les opérations effectuées, ainsi que des formats de
        données standards (tels que JSON, XML) pour la transmission de
        données. L'état des réponses est représenté sous la forme de codes
        d'état HTTP. Par exemple, le code 200 représente le succès, le code
        404 représente la ressource introuvable, etc.\newline  Cela permet aux
        clients de rapidement déterminer le résultat de la réponse en fonction
        du code d'état, sans avoir besoin de parser des informations de
        réponse complexes. Par rapport à ``SOAP'' qui ne peut utiliser que XML
        pour transférer des informations, l'API REST simplifie et facilite
        l'échange de données entre les clients et les serveurs.
  \item
        \textbf{Morgan} \protect\hyperlink{ref-morgan}{{[}20{]}} : Morgan est
        un middleware JavaScript permettant d'enregistrer les journaux de
        session HTTP. Elle peut produire des informations dans plusieurs
        endroits (la console, les fichiers, les en-têtes HTTP\ldots) pour nous
        aider à déboguer et à analyser le fonctionnement de leurs
        applications. De plus, Morgan peut être facilement ajouté aux
        applications Node.js en installant simplement les dépendances à l'aide
        de npm et en les introduisant dans l'application à l'aide d'Express.js
        \protect\hyperlink{ref-Express_js}{{[}19{]}}. Par rapport à d'autres
        outils similaires, Morgan est plus facile à utiliser, car il ne
        nécessite pas d'écriture de code supplémentaire. Ainsi, Morgan produit
        une plus grande variété des cibles de sortie.
  \item
        \textbf{Helmet} \protect\hyperlink{ref-helmet}{{[}21{]}} : Helmet est
        un middleware pour les applications Node.js, conçu pour aider à
        protéger les applications Web contre certaines attaques Web courantes.
        De plus, l'utilisation de Helmet est très facile, en installant
        simplement les dépendances à l'aide de npm et en les introduisant dans
        l'application à l'aide d'Express.js
        \protect\hyperlink{ref-Express_js}{{[}19{]}}. Et Helmet est un
        middleware populaire pour Node.js, bénéficiant d'une maintenance
        actifs de la communauté, ce qui nous permet de bénéficier facilement
        d'aide et de support dans la communauté.
\end{itemize}

\hypertarget{tuxe2ches-ruxe9alisuxe9es}{%
  \subsection{Tâches réalisées}\label{tuxe2ches-ruxe9alisuxe9es}}

\begin{itemize}
  \tightlist
  \item
        Intégration d'un IDE similaire aux \emph{Playground} de
        \href{https://OCaml.org/play}{OCaml} et
        \href{https://rescript-lang.org/try}{Rescript}
  \item
        Implémentation d'un éditeur de code supportant la syntaxe de
        \textbf{MiniML}
  \item
        Liaison entre le code Javascript et OCaml à l'aide de Js\_of\_OCaml
  \item
        Implémentation de plusieurs modes de traitement du code
        \textbf{MiniML}:

        \begin{itemize}
          \tightlist
          \item
                Affichage de l'AST MiniML
          \item
                Affichage de l'AST de \textbf{Call-By-Push-Value}
          \item
                Affichage de l'équation résultant de l'analyse statique
          \item
                Vers Représentation Interne \textbf{Autobill}
        \end{itemize}
  \item
        Remontée d'erreurs et affichage dynamique sur l'interface
  \item
        Implémentation du solveur d'équations MiniZinc côté client
  \item
        Mise en place d'un serveur distant manipulant les libraires OCaml du
        projet et le solveur MiniZinc
  \item
        Exposition du serveur avec une API REST
  \item
        Mise en relation du client et du serveur
\end{itemize}

\newpage

\hypertarget{miniml}{%
  \section{MiniML}\label{miniml}}

\hypertarget{description-de-miniml}{%
  \subsection{Description de MiniML}\label{description-de-miniml}}

\textbf{MiniML} émerge du choix par nos encadrants de créer un langage
fonctionnel simple et accessible pour les utilisateurs d'Autobill
servant d'abstraction à \textbf{CBPV}. Dans le cadre de ce projet
MiniML, dispose d'une implémentation écrite en \textbf{OCaml}. Nous
avons pris la décision de rendre la syntaxe MiniML parfaitement
compatible avec OCaml simplifiant les comparaisons avec RAML
\protect\hyperlink{ref-RAML}{{[}3{]}}.

Le développement de \textbf{MiniML} suivant les besoins de nos
encadrants celui-ci est pour l'instant sans effets de bord.

\hypertarget{call-by-push-value}{%
  \subsubsection{Call-By-Push-Value}\label{call-by-push-value}}

Le paradigme de traitement de langage \textbf{Call-By-Push-Value}
utilisé par \textbf{Autobill} permet à l'aide d'une seule sémantique de
traiter deux types de stratégies d'évaluation différentes, \textbf{Call
  By Value} utilisée par \textbf{OCaml} et \textbf{Call By Name} utilisée
par \textbf{Haskell} pour mettre en place l'évaluation \emph{Lazy}. Dans
CBPV, une distinction a lieu entre les calculs et les valeurs permettant
de décider en détail comment ceux-ci sont évalués. Nous permettant, lors
de la traduction depuis un autre langage, de choisir le type de
stratégie utilisée.

\hypertarget{contenu-actuel}{%
  \subsubsection{Contenu actuel}\label{contenu-actuel}}

Le contenu actuel de \textbf{MiniML} est divisé en deux. Une partie
noyau qui contient les éléments de base du langage servant de briques de
construction pour la second partie ou se trouvent les types de données
et les fonctions de haut niveau.

Le noyau de \textbf{MiniML} contenant deux types de base les entiers et
les booléens ainsi que les opérateurs de base. À partir de ces éléments,
il est possible de construire des types de données plus complexes en
exprimant des types paramétrés et en les combinant. Les listes sont un
exemple de typique de structures de données construit à partir de ces
mécanismes. Comme dans tout langage fonctionnel, il est possible de
définir des fonctions anonymes ou non et de les passer en paramètre à
d'autres fonctions. Il est également possible de définir des variables
globales et locales.

La partie contenant les types de données et les fonctions de haut niveau
est la plus importante, car elle agit en tant que vitrine
d'\textbf{Autobill} avec pour but de fournir un ensemble de types de
données complexes dont l'analyse amortie est possible et mettant en
lumière les apports d'\textbf{Autobill}. \newline Toujours en cours de
développement, cette partie, basée sur le noyau, contient pour l'instant
trois types de données les listes, les files et les arbres binaires.

\hypertarget{duxe9pendances}{%
  \subsubsection{Dépendances}\label{duxe9pendances}}

À l'instar du développement de l'interface web, la question des
dépendances est cruciale pour MiniML. En effet pour n'avoir qu'une seule
implémentation de MiniML et donc limiter l'effort de développement, il
est nécessaire de ne choisir que des librairies qui sont parfaitement
compatibles avec les deux architectures du projet.

\begin{itemize}
  \tightlist
  \item
        \textbf{Menhir} \protect\hyperlink{ref-menhir}{{[}23{]}}:
        \emph{Menhir} est l'unique dépendance de l'implémentation de MiniML.
        C'est une librairie qui génère des analyseurs syntaxiques en OCaml et
        nous évitant le développement d'un analyseur syntaxique rigide. C'est
        à la suite de différents tests de compatibilité avec les deux
        architectures du projet que nous avons choisi cette librairie nous
        permettant un gain en temps et en flexibilité non négligeable. Menhir
        est disponible sous licence GPL
\end{itemize}

\hypertarget{un-exemple-de-code-miniml}{%
  \subsection{Un exemple de code MiniML}\label{un-exemple-de-code-miniml}}

Cet exemple est une implémentation possible d'une file d'attente en
\textbf{MiniML}. Dans le prochain rapport, nous allons nous baser sur
une variante de ce code pour décrire, avec des schémas de traduction
basés sur la spécification du langage, comment l'on passe d'un code
\textbf{MiniML} à un code \textbf{Call-By-Push-Value} reçu en entrée par
\textbf{Autobill}.

Le choix de ce code est motivé par le fait qu'il est assez simple et que
ce dernier peut mettre en avant les résultats plus précis qu'une analyse
amortie permet d'obtenir.

\begin{Shaded}
  \begin{Highlighting}[]
    \KeywordTok{type}\NormalTok{ \textquotesingle{}a }\DataTypeTok{option}\NormalTok{ =}
    \NormalTok{  | }\DataTypeTok{None}
    \NormalTok{  | }\DataTypeTok{Some} \KeywordTok{of}\NormalTok{ \textquotesingle{}a}
    \NormalTok{  ;;}

    \KeywordTok{let}\NormalTok{ createQueue = ([],[]);;}

    \KeywordTok{let}\NormalTok{ push file elem = }
    \NormalTok{  (}\KeywordTok{match}\NormalTok{ file }\KeywordTok{with}
    \NormalTok{  | (a,b) {-}\textgreater{} (a,(elem::b)))}
    \NormalTok{  ;;}

    \KeywordTok{let}\NormalTok{ pop file =}
    \NormalTok{    (}\KeywordTok{match}\NormalTok{ file }\KeywordTok{with}
    \NormalTok{    | (debut, fin) {-}\textgreater{} }
    \NormalTok{      (}\KeywordTok{match}\NormalTok{ debut }\KeywordTok{with}
    \NormalTok{      | [] {-}\textgreater{} (}
    \KeywordTok{match}\NormalTok{ (rev fin) }\KeywordTok{with}
    \NormalTok{                | [] {-}\textgreater{} (}\DataTypeTok{None}\NormalTok{,debut,fin)}
    \NormalTok{                | (hd :: tail) {-}\textgreater{} ((}\DataTypeTok{Some}\NormalTok{(hd)), tail ,[])}
    \NormalTok{              )}
    \NormalTok{      | (hd::tail) {-}\textgreater{} ((}\DataTypeTok{Some}\NormalTok{(hd)),tail,fin ))}
    \NormalTok{    )}
    \NormalTok{  ;;}

    \KeywordTok{let}\NormalTok{ elems = [}\DecValTok{1}\NormalTok{;}\DecValTok{2}\NormalTok{;}\DecValTok{3}\NormalTok{;}\DecValTok{4}\NormalTok{;}\DecValTok{5}\NormalTok{;}\DecValTok{6}\NormalTok{;}\DecValTok{7}\NormalTok{];;}
    \KeywordTok{let}\NormalTok{ queue = (fold\_left push createFile elems);;}
    \NormalTok{  (pop queue)}
  \end{Highlighting}
\end{Shaded}

\hypertarget{conclusion-et-tuxe2ches-uxe0-ruxe9aliser}{%
  \section{Conclusion et tâches à
    réaliser}\label{conclusion-et-tuxe2ches-uxe0-ruxe9aliser}}

\hypertarget{conclusion}{%
  \subsection{Conclusion}\label{conclusion}}

La réalisation de cette interface a fait intervenir un large panel de
sujets en lien avec la formation du Master d'informatique STL et mis à
profit les connaissances acquises lors de ce semestre. En premier lieu,
le cours d'analyse de programme statique
\protect\hyperlink{ref-APS}{{[}24{]}} pour toute la partie MiniML et le
processus de transformation vers CBPV. Puis, les cours de programmation
concurrente répartie, réactive et réticulaire
\protect\hyperlink{ref-PC3R}{{[}22{]}}, notamment pour la partie
réticulaire et l'architecture d'applications Web modernes.

Le projet est à un stade d'avancement satisfaisant. Autobill étant
encore en phase expérimentale, celui-ci est alimenté continuellement de
nouveautés et corrections que l'on doit intégrer. La suite consistera
surtout à consolider les bases établies sur tous les aspects du projet
présentés dans ce rapport et les adapter aux changements d'Autobill.
Aussi, il serait intéressant à titre de démonstration de comparer notre
solution avec celle de Jan Hoffmann et l'interface de RAML
\protect\hyperlink{ref-RAML}{{[}3{]}}, mentionnée en section 1.

\hypertarget{miniml-1}{%
  \subsection{MiniML}\label{miniml-1}}

\begin{itemize}
  \tightlist
  \item
        Ajout de sucre syntaxique. (Records, Operateurs Infixes, \ldots)
  \item
        Ajout d'une librairie standard.
  \item
        Spécification complète du langage.
  \item
        Bibliothèque de structures de données complexes
  \item
        Règles de traduction de \textbf{MiniML} vers \textbf{Autobill}
  \item
        Schémas de traduction d'une structure \emph{FIFO} vers \textbf{LCBPV}
\end{itemize}

\hypertarget{serveur}{%
  \subsection{Serveur}\label{serveur}}

\begin{itemize}
  \tightlist
  \item
        Affichage des erreurs
  \item
        Réalisation des autres services pour MiniML
  \item
        Réalisation de génération de solution depuis le code Autobill
\end{itemize}

\hypertarget{client}{%
  \subsection{Client}\label{client}}

\begin{itemize}
  \tightlist
  \item
        Retouches esthétiques
  \item
        Affichage des erreurs sur plusieurs lignes
  \item
        Couverture d'erreurs à traiter la plus grande possible, afin d'éviter
        les blocages du client
  \item
        ``Benchmark'' la résolution d'équations plus complexes avec le
        MiniZinc client
  \item
        Proposer des programmes d'exemples à lancer, demandant des lourdes
        allocations mémoires.
\end{itemize}

\hypertarget{tests}{%
  \subsection{Tests}\label{tests}}

\begin{itemize}
  \item
        Comparaison d'architectures Full-Client vs Client-Serveur
  \item
        Comparaison \textbf{RAML} vs \textbf{Autobill}
\end{itemize}

\newpage

\bibliographystyle{acm}
\bibliography{biblio}

\end{document}