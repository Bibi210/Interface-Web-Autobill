\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  12pt,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\usepackage{stmaryrd}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Palatino}
  \setsansfont[]{Helvetica}
  \setmonofont[]{Menlo}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin = 1.2in]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
\ifPDFTeX
\else
\babelfont[french]{rm}[]{Palatino}
\fi
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={MiniML Spec},
  pdfauthor={Fazazi Zeid; Luo Yukai; Dibassi Brahima},
  pdflang={fr},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={NavyBlue},
  pdfcreator={LaTeX via pandoc}}

\title{MiniML Spec}
\author{Fazazi Zeid \and Luo Yukai \and Dibassi Brahima}
\date{2023-05-06}

\begin{document}
\maketitle

\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\allowdisplaybreaks
\pagebreak

\hypertarget{grammaire}{%
  \section{Grammaire}\label{grammaire}}

  
\newcommand{\grammarRule}[1]{\; \textbf{<\textcolor{Blue}{#1}>} \;}
\newcommand{\grammarRuleUnSpaced}[1]{\textbf{<\textcolor{Blue}{#1}>}}
\newcommand{\nTime}[1]{\; #1\text{*} \;}
\newcommand{\nPlus}[1]{\; #1\text{+} \;}
\newcommand{\isToken}[1]{\; \textit{`\textcolor{Maroon}{#1}`} \;}
\newcommand{\isTokenLCBPV}[1]{\; \textit{`\textcolor{Green}{#1}`} \;}
\newcommand{\isRangeToken}[2]{\; \textit{`\textcolor{Maroon}{#1} - \textcolor{Maroon}{#2}`} \;}
\newcommand{\isExtentionML}[1]{ \textit{\textcolor{Orange}{#1}} \quad }

Voici la grammaire BNF du language MiniML.\
Les extensions non compatibles avec Ocaml mais compatible avec \textbf{Autobill} sont en \isExtentionML{Orange}.

\hypertarget{Elements Nommés}{%
  \subsection{Elements Nommés}\label{Elements Nommés}}

\begin{align*}
  \grammarRule{Id} ::= \quad             & \nPlus{[\isRangeToken{a}{z} \isRangeToken{A}{Z} \isRangeToken{0}{9} \isToken{\_}]} \\
  \grammarRule{ConstructeurId} ::= \quad & [\isRangeToken{A}{Z}] \grammarRule{Id}                                             \\
  \grammarRule{Vartype} ::= \quad        & \isToken{'}[\isRangeToken{a}{z}] \; \nTime{[\isRangeToken{0}{9}]}
\end{align*}

\hypertarget{programmes}{%
  \subsection{Programmes}\label{programmes}}


\begin{align*}
  \grammarRule{Prog} ::= \quad & |\quad \grammarRule{Expr}                                  \\
                               & |\quad \grammarRule{Def}  \isToken{;;}  \grammarRule{Prog}
\end{align*}

\hypertarget{definitions}{%
  \subsection{Definitions}\label{definitions}}

\begin{align*}
  \grammarRule{Def} ::= \quad              & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr}                                                  \\
                                           & |\quad \isToken{type} \nTime{\grammarRuleUnSpaced{Vartype}} \grammarRule{Id} \isToken{=} \grammarRule{NewContructors} \\
  \\
  \grammarRule{NewContructors} ::=   \quad & |\quad  \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}                                                  \\
                                           & |\quad  \grammarRule{NewContructors} \isToken{|} \grammarRule{NewContructors}                                         \\
  \isExtentionML{Debut Extension}          & |\quad \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}  \isToken{with}  \grammarRule{ParamAssigns}       \\
  \\
  \grammarRule{ParamAssigns} ::= \quad     & |\quad \grammarRule{VarType} \isToken{=} \grammarRule{ParmExpr}                                                       \\
                                           & |\quad \grammarRule{ParamAssigns} \isToken{,} \grammarRule{ParamAssigns}                                              \\
  \grammarRule{ParmExpr} ::= \quad
                                           & |\quad \isToken{1}                                                                                                    \\
                                           & |\quad \grammarRule{VarType}                                                                                          \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{+} \grammarRule{ParmExpr}                                                      \\
  \isExtentionML{Fin Extension}            & |\quad \grammarRule{ParmExpr} \isToken{*} \grammarRule{ParmExpr}                                                      \\
\end{align*}
\pagebreak

\hypertarget{expressions}{%
  \subsection{Expressions}\label{expressions}}
\begin{align*}
  \grammarRule{Litteral}  \quad ::=  \quad       & |\quad \nPlus{[\isRangeToken{0}{9}]}                                                                                                                                                  \\
                                                 & |\quad [\isToken{true}|\isToken{false}]                                                                                                                                               \\
                                                 & |\quad \isToken{(} \isToken{)}                                                                                                                                                        \\
  \\
  \grammarRule{Expr}  \quad ::=  \quad           & |\quad \grammarRule{Litteral}                                                                                                                                                         \\
                                                 & |\quad \grammarRule{Id}                                                                                                                                                               \\
                                                 & |\quad \grammarRule{UnaryOperator}  \grammarRule{Expr}                                                                                                                                \\
                                                 & |\quad  \grammarRule{Expr} \grammarRule{BinaryOperator}    \grammarRule{Expr}                                                                                                         \\
                                                 & |\quad \grammarRule{Expr}  \grammarRule{Expr}                                                                                                                                         \\
                                                 & |\quad \grammarRule{Expr} \isToken{,}  \grammarRule{Expr}                                                                                                                             \\
                                                 & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr} \isToken{in} \grammarRule{Expr}                                                                                  \\
                                                 & |\quad \isToken{fun} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                                                                                                \\
                                                 & |\quad \isToken{fun} \isToken{rec} \grammarRule{Id} \grammarRule{Id} \isToken{->}  \grammarRule{Expr}                                                                                 \\
                                                 & |\quad \grammarRule{ConstructeurId}  \grammarRule{Expr}                                                                                                                               \\
                                                 & |\quad \isToken{match} \grammarRule{Expr} \isToken{with} \grammarRule{MatchCase}                                                                                                      \\
  \\
  \grammarRule{UnaryOperator}  \quad ::=  \quad  & \isToken{not}                                                                                                                                                                         \\
  \grammarRule{BinaryOperator}  \quad ::=  \quad & [\isToken{and} \,|\, \isToken{or} \,|\, \isToken{+} \,|\, \isToken{-} \,|\, \isToken{/} \,|\, \isToken{\%} \,|\, \isToken{*} \,|\, \isToken{<} \,|\, \isToken{>}  \,|\, \isToken{=} ] \\
\end{align*}

\hypertarget{filtrage-et-motifs}{%
  \subsection{Filtrage et Motifs}\label{filtrage-et-motifs}}
\begin{align*}
  \grammarRule{MatchCase}  \quad ::=  \quad & |\quad  \grammarRule{Pattern} \isToken{->}  \grammarRule{Expr}     \\
                                            & |\quad \grammarRule{MatchCase} \isToken{|} \grammarRule{MatchCase} \\
  \\
  \grammarRule{Pattern} \quad ::=  \quad    & |\quad \grammarRule{Litteral}                                      \\
                                            & |\quad \grammarRule{Id}                                            \\
                                            & |\quad \grammarRule{Pattern}  \isToken{,} \grammarRule{Pattern}    \\
                                            & |\quad \grammarRule{ConstructeurId} \; \grammarRule{Pattern}       \\
\end{align*}

\pagebreak

\hypertarget{types-1}{%
  \subsection{Types}\label{types-1}}

\begin{align*}
  \grammarRule{Type}    \quad ::=  \quad & |\quad \grammarRule{Vartype}                              \\
                                         & |\quad \grammarRule{Id}                                   \\
                                         & |\quad \grammarRule{Type}   \grammarRule{Type}            \\
                                         & |\quad \grammarRule{Type} \isToken{->} \grammarRule{Type} \\
                                         & |\quad \grammarRule{Type} \isToken{*}  \grammarRule{Type} \\
\end{align*}

\hypertarget{semantique-de-traduction}{%
  \section{Semantique de traduction}\label{semantique-de-traduction}}

\newcommand{\translateNode}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\translateResult}[1]{\llbracket #1 \rrbracket}
\newcommand{\isElemMiniML}[1]{\; \textcolor{Maroon}{#1} \;}
\newcommand{\isElemLCBPV}[1]{\textcolor{ForestGreen}{#1}}
\newcommand{\spaced}[1]{\; #1 \;}
\newcommand{\Tab}{\quad \quad \quad \quad \quad \quad \;}
\hypertarget{notation}{%
  \subsection{Notation}\label{notation}}
$ \translateNode{let \; v \; = \; e_1 \; in \; e_2}{Expr}  \rightarrow let \; v = \; \translateResult{e_1} \; in \; \translateResult{e_2}$
\begin{itemize}
  \tightlist
  \item
        $\translateNode{\_}{Expr}  \rightarrow $ est la traduction d'un noeud expr du langage MiniML vers le langage LCBPV
        \begin{itemize}
          \tightlist
          \item
                A l'interieur des $\translateResult{}$  les elements propre au langage MiniML qui sont traduit vers le langage LCBPV
          \item
                A l'exterieur des $\translateResult{}$  les elements propre au langage LCBPV
        \end{itemize}
  \item
        $X_n$ est le n-ième sous-noeud de l'arbre de syntaxe abstrait \newline
        Selon les cas $X$ peut être :
        \begin{itemize}
          \tightlist
          \item
                $e$ pour les expressions
          \item
                $p$ pour les motifs
          \item
                $t$ pour les types
          \item
                $d$ pour les définitions
                \begin{itemize}
                  \tightlist
                  \item
                        $dc$ pour les définitions de constructeurs
                \end{itemize}
          \item
                $v$ pour les elements nommées
        \end{itemize}
  \item
        $X_1 \dots X_n$ est la liste des sous-noeuds de type $X$ allant de $1$ à $n$
\end{itemize}

\hypertarget{programmes-1}{%
  \subsection{Programmes}\label{programmes-1}}

Un programme MiniML est une suite de taille arbitraire de définitions suivie d'une expression.

\begin{align*}
  \translateNode{d_1 \dots d_n \, e}{Prog} \rightarrow \translateResult{d_1 \dots d_n}\; return \; \translateResult{e}
\end{align*}

\pagebreak

\subsection{Définitions}\label{def}

On définit l'operation de traduction \(\translateNode{\_}{Def}\) selon les cas de construction
des définitions précisées par la règle de grammaire : \grammarRule{Def}

On distingue deux noeuds de types \grammarRule{Def}:
\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Variables Globales},
  \item
        Les définitions de \textbf{Types}.
\end{itemize}
\begin{align*}
  \text{(VARDEF)}  \quad & \translateNode{let \, v \, = \, e}{Def} \rightarrow   let \, v \, = \; \translateResult{e}     \\
  \\
  \text{(TYPDEF) } \quad & \translateNode{type \, \, v_1 \dots v_N \, = \, dc_1 \dots  dc_N}{Def}                         \\
  \rightarrow \;         & data \translateResult{v_1} \translateResult{\dots v_N} : + = \translateResult{dc_1 \dots dc_N} \\
\end{align*}
\subsubsection{Définitions de Constructeurs}\label{defConstruct}

On définit l'operation de traduction \(\translateNode{\_}{DefContructors}\) selon les cas de construction précisées par la règle de grammaire : \grammarRule{NewContructors}

On distingue deux noeuds de types \grammarRule{NewContructors}:
\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Constructeurs Classiques} qui sont compatibles avec OcamL
  \item
        Les définitions de \textbf{Constructeurs Equationnels} qui sont une extension spécifique pour \textbf{Autobill} dont la traduction n'est pas encore mise en place
\end{itemize}


\begin{align*}
  \\\text{(MLCONSTRUCTDEF)} \quad & \translateNode{v \; of \; t}{DefContructors}   \rightarrow   v\translateResult{t}                \\
\end{align*}

\pagebreak
\subsection{Types}\label{types-2}

On définit l'operation de traduction \(\translateNode{\_}{Type}\) selon les cas de construction
des types précisées par la règle de grammaire : \grammarRule{Type}

On distingue 4 noeuds d'interêt de types $Type$:
\begin{itemize}
  \tightlist
  \item
        Les \textbf{Variables de types}.
  \item
        Les \textbf{Applications de types}.
  \item
        Les \textbf{Lambda}
  \item
        Les \textbf{Tuples}.
\end{itemize}
\begin{align*}
  \text{(TVAR) }  & \translateNode{v}{Type} \rightarrow  v                                                                           \\
  \text{(TAPP) }  & \translateNode{t_1 t_2}{Type} \rightarrow  \translateResult{t_1} \, \translateResult{t_2}                        \\
  \text{(TCLOS) } & \translateNode{t_1 \text{->} t_2}{Type} \rightarrow  \translateResult{t_1} \, \text{->} \, \translateResult{t_2} \\
  \text{(TTUPLE)} & \translateNode{t_1 * t_2}{Type} \rightarrow  \translateResult{t_1} \, , \, \translateResult{t_2}                 
\end{align*}

\subsection{Expressions}\label{exprs}

On définit l'operation de traduction \(\translateNode{\_}{Expr}\) selon les cas de construction
des expressions précisées par la règle de grammaire : \grammarRule{Expr}

On distingue 8 noeuds d'Intérêt de types \grammarRule{Expr}:
\begin{itemize}
  \tightlist
  \item
        Les \textbf{Tuples}.
  \item
        Les \textbf{Variables}.
  \item
        Les \textbf{Appels de fonctions}.
  \item
        Les \textbf{Fixation}.
  \item
        Les \textbf{Lambda}.
  \item
        Les \textbf{Fonctions Recursive}.
  \item
        Les \textbf{Constructions}.
  \item
        Les \textbf{Correspondance de motifs}.
\end{itemize}
\begin{align*}
  \text{(TUPLE)} \quad     & \translateNode{e_1 \, , \, e_2}{Expr} \rightarrow \text{Tuple}(\translateResult{e_1} \, , \, \translateResult{e_2})                                                          \\
  \text{(VAR)} \quad       & \translateNode{v}{Expr} \rightarrow v                                                                                                                                          \\
  \text{(LAMBDA)} \quad    & \translateNode{fun \, v \, \rightarrow \, e}{Expr}    \rightarrow  exp(  \; get \; | \; call(v) \; \text{->}  \; thunk\translateResult{e}  )                                   \\
  \text{(FUN REC)} \quad   & \translateNode{fun \, rec \, v_1 \, v_2 \rightarrow \, e}{Expr}      \rightarrow exp( \; rec \; v_1 \; is \; get \; | \; call(v_2) \; \text{->}  \; thunk\translateResult{e} ) \\
  \text{(CALL)} \quad      & \translateNode{e_1 e_2}{Expr}     \rightarrow  \{                                                                                                                              \\
                           & \Tab open \; exp \; v_1  = \translateResult{e_1}                                                                                                                               \\
                           & \Tab force \; thunk(v_2) = (v_1).call\translateResult{e_2}                                                                                                                     \\
                           & \Tab return \; v_2                                                                                                                                                             \\
                           & \}                                                                                                                                                                             \\
  \text{(BIND)} \quad      & \translateNode{let \; v \; = \; e_1 \; in \; e_2}{Expr}  \rightarrow  \{                                                                                                       \\
                           & \Tab let \; v = \translateResult{e_1}                                                                                                                                          \\
                           & \Tab return \;\translateResult{e_2}                                                                                                                                            \\
                           & \}                                                                                                                                                                             \\
  \text{(CONSTRUCT)} \quad & \translateNode{v \, e}{Expr} \rightarrow v(\translateResult{e})                                                                                                                \\
  \text{(MATCH)} \quad     & \translateNode{match \, e \, with \, c_1 \dots c_N }{Expr}\rightarrow  match \, \translateResult{e} \, with \, \translateResult{c_1} \dots \translateResult{c_N} \; end                        \\
\end{align*}
\subsection{Motifs et Filtrage}\label{motifs-et-filtrage}

\[ Case(p,e) \rightarrow \llbracket Case(p,e) \rrbracket_{Case} \rightarrow \alpha \]

On définit la relation \({Case}\) selon les cas de construction
des motif de correspondance. Les cas de construction des motif de
correspondance sont donnés par les clauses des règles syntaxiques. Un
motif de correspondance est dit traduisible si chacune de ses clauses
peut être traduite.
\begin{itemize}
  \tightlist
  \item
        \(p\) est un motif
  \item
        \(e\) est l'expression qui sera évaluée si le motif est vérifié
\end{itemize}
\begin{align*}
  \text{(PATTAG)} \quad & Case(ConstructorPattern((n,c)), e)
  \\ &\rightarrow  MatchPatTag(ConsNamed(n), \llbracket c \rrbracket_{Case}, \llbracket e \rrbracket_{Expr})        \\
  \\
  \text{(PATVAR)} \quad & Case(VarPattern(x), e, l)
  \rightarrow  MatchPatVar((x, l), \llbracket e \rrbracket_{Expr}, l)
\end{align*}

\end{document}
