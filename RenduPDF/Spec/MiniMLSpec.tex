\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  12pt,
]{article}
\usepackage{amsmath,amssymb}
\usepackage{iftex}
\usepackage{stmaryrd}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
  \setmainfont[]{Palatino}
  \setsansfont[]{Helvetica}
  \setmonofont[]{Menlo}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\usepackage[margin = 1.2in]{geometry}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{french}
\ifPDFTeX
\else
\babelfont[french]{rm}[]{Palatino}
\fi
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={MiniML Spec},
  pdfauthor={Fazazi Zeid; Luo Yukai; Dibassi Brahima},
  pdflang={fr},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={NavyBlue},
  pdfcreator={LaTeX via pandoc}}

\title{MiniML Spec}
\author{Fazazi Zeid \and Luo Yukai \and Dibassi Brahima}
\date{2023-05-06}

\begin{document}
\maketitle

\newpage

{
  \hypersetup{linkcolor=}
  \setcounter{tocdepth}{3}
  \tableofcontents
}
\allowdisplaybreaks
\pagebreak

\hypertarget{grammaire}{%
  \section{Grammaire}\label{grammaire}}

\newcommand{\grammarRule}[1]{\; \textbf{<\textcolor{Blue}{#1}>} \;}
\newcommand{\grammarRuleUnSpaced}[1]{\textbf{<\textcolor{Blue}{#1}>}}
\newcommand{\nTime}[1]{\; #1\text{*} \;}
\newcommand{\nPlus}[1]{\; #1\text{+} \;}
\newcommand{\isToken}[1]{\; \textit{`\textcolor{Maroon}{#1}`} \;}
\newcommand{\isRangeToken}[2]{\; \textit{`\textcolor{Maroon}{#1} - \textcolor{Maroon}{#2}`} \;}

Voici la grammaire BNF de notre langage MiniML.

\hypertarget{Identificateurs}{%
  \subsection{Identificateurs}\label{Identificateurs}}

\begin{align*}
  \grammarRule{Id} ::= \quad             & \nTime{[\isRangeToken{a}{z} \isRangeToken{A}{Z} \isRangeToken{0}{9} \isToken{\_}]} \\
  \grammarRule{ConstructeurId} ::= \quad & [\isRangeToken{A}{Z}] \grammarRule{Id}                                             \\
  \grammarRule{Vartype} ::= \quad        & \isToken{'}[\isRangeToken{a}{z}] \; \nTime{[\isRangeToken{0}{9}]}
\end{align*}

\hypertarget{programmes}{%
  \subsection{Programmes}\label{programmes}}


\begin{align*}
  \grammarRule{Prog} ::= \quad & |\quad \grammarRule{Expr}                                  \\
                               & |\quad \grammarRule{Def}  \isToken{;;}  \grammarRule{Prog}
\end{align*}

\hypertarget{definitions}{%
  \subsection{Definitions}\label{definitions}}

\begin{align*}
  \grammarRule{Def} ::= \quad              & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr}                                                  \\
                                           & |\quad \isToken{type} \nTime{\grammarRuleUnSpaced{Vartype}} \grammarRule{Id} \isToken{=} \grammarRule{NewContructors} \\
  \\
  \grammarRule{NewContructors} ::=   \quad & |\quad  \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}                                                  \\
                                           & |\quad \grammarRule{ConstructeurId} \isToken{of} \grammarRule{Type}  \isToken{with}  \grammarRule{ParamAssigns}       \\
                                           & |\quad  \grammarRule{NewContructors} \isToken{|} \grammarRule{NewContructors}                                         \\
  \\
  \grammarRule{ParamAssigns} ::= \quad     & |\quad \grammarRule{VarType} \isToken{=} \grammarRule{ParmExpr}                                                       \\
                                           & |\quad \grammarRule{ParamAssigns} \isToken{,} \grammarRule{ParamAssigns}                                              \\
  \grammarRule{ParmExpr} ::= \quad
                                           & |\quad \isToken{1}                                                                                                    \\
                                           & |\quad \grammarRule{VarType}                                                                                          \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{+} \grammarRule{ParmExpr}                                                      \\
                                           & |\quad \grammarRule{ParmExpr} \isToken{*} \grammarRule{ParmExpr}                                                      \\
\end{align*}
\pagebreak

\hypertarget{expressions}{%
  \subsection{Expressions}\label{expressions}}
\begin{align*}
  \grammarRule{Litteral}  \quad ::=  \quad       & |\quad \nPlus{[\isRangeToken{0}{9}]}                                                                                                                                                  \\
                                                 & |\quad [\isToken{true}|\isToken{false}]                                                                                                                                               \\
                                                 & |\quad \isToken{(} \isToken{)}                                                                                                                                                        \\
  \\
  \grammarRule{Expr}  \quad ::=  \quad           & |\quad \grammarRule{Litteral}                                                                                                                                                         \\
                                                 & |\quad \grammarRule{Id}                                                                                                                                                               \\
                                                 & |\quad \grammarRule{UnaryOperator}                                                                                                                                                    \\
                                                 & |\quad \grammarRule{BinaryOperator}                                                                                                                                                   \\
                                                 & |\quad \isToken{(} \grammarRule{Expr}  \grammarRule{Expr}         \isToken{)}                                                                                                         \\
                                                 & |\quad \isToken{let} \grammarRule{Id} \isToken{=} \grammarRule{Expr} \isToken{in} \grammarRule{Expr}                                                                                  \\
                                                 & |\quad \isToken{fun} \grammarRule{Id} \rightarrow  \grammarRule{Expr}                                                                                                                 \\
                                                 & |\quad \isToken{fun} \isToken{rec} \grammarRule{Id} \grammarRule{Id} \rightarrow  \grammarRule{Expr}                                                                                  \\
                                                 & |\quad \grammarRule{Expr} \isToken{,} \grammarRule{Expr}                                                                                                                              \\
                                                 & |\quad \grammarRule{ConstructeurId}  \grammarRule{Expr}                                                                                                                               \\
                                                 & |\quad \isToken{match} \grammarRule{Expr} \isToken{with} \grammarRule{MatchCase}                                                                                                      \\
  \\
  \grammarRule{UnaryOperator}  \quad ::=  \quad  & \isToken{not}                                                                                                                                                                         \\
  \grammarRule{BinaryOperator}  \quad ::=  \quad & [\isToken{and} \,|\, \isToken{or} \,|\, \isToken{+} \,|\, \isToken{-} \,|\, \isToken{/} \,|\, \isToken{\%} \,|\, \isToken{*} \,|\, \isToken{<} \,|\, \isToken{>}  \,|\, \isToken{=} ] \\
\end{align*}

\hypertarget{filtrage-et-motifs}{%
  \subsection{Filtrage et Motifs}\label{filtrage-et-motifs}}
\begin{align*}
  \grammarRule{MatchCase}  \quad ::=  \quad & |\quad  \grammarRule{Pattern} \rightarrow  \grammarRule{Expr}      \\
                                            & |\quad \grammarRule{MatchCase} \isToken{|} \grammarRule{MatchCase} \\
  \\
  \grammarRule{Pattern} \quad ::=  \quad    & |\quad \grammarRule{Litteral}                                      \\
                                            & |\quad \grammarRule{Id}                                            \\
                                            & |\quad  \grammarRule{Pattern} \isToken{,} \grammarRule{Pattern}    \\
                                            & |\quad \grammarRule{ConstructeurId} \; \grammarRule{Pattern}       \\
\end{align*}

\pagebreak

\hypertarget{types-1}{%
  \subsection{Types}\label{types-1}}

\begin{align*}
  \grammarRule{Type}    \quad ::=  \quad & |\quad \grammarRule{Vartype}                                        \\
                                         & |\quad \grammarRule{Id}                                             \\
                                         & |\quad\grammarRule{Type}  \isToken{*} \grammarRule{Type}            \\
                                         & |\quad \isToken{(} \grammarRule{Type} \grammarRule{Type}\isToken{)} \\
\end{align*}

\hypertarget{semantique-de-traduction}{%
  \section{Semantique de traduction}\label{semantique-de-traduction}}

\hypertarget{programmes-1}{%
  \subsection{Programmes}\label{programmes-1}}

\[ Prog[cs] \rightarrow \llbracket Prog[cs] \rrbracket_{Prog}  \] Un programme MiniML
est une suite de commandes \([cs]\) qui est traduite en un programme
\(x\) en LCBPV. Un programme est dit traduisible si la suite de
commandes \([cs]\) qui le compose peut-être traduite.
\begin{align*}
   & Prog[cs] \rightarrow  \llbracket Prog[cs] \rrbracket_{Cmds} \rightarrow Prog'(\llbracket cs \rrbracket_{Cmds} )
\end{align*}

\hypertarget{suites-de-commandes}{%
  \subsection{Suites de commandes}\label{suites-de-commandes}}

\[ cs \rightarrow \llbracket cs \rrbracket_{Cmds} \rightarrow (\gamma,\omega,\upsilon) \] Le
resultat de la traduction d'une suite de commandes \(cs\) est un triplet
\((\gamma,\omega,\upsilon)\) où:

\begin{itemize}
  \tightlist
  \item
        \(\gamma\) est le resultat de la traduction des variables globales,
  \item
        \(\omega\) est le resultat de la traduction des definitions de types
  \item
        \(\upsilon\) est la dernière expression traduite.
\end{itemize}

Ce triplet est rendu nécessaire par la sémantique de LCBPV qui ne permet
pas de définir des variables globales comme en MiniML. Cela a aussi pour
conséquence un changement de portée entre les déclarations de type en
MiniML et en LCBPV.
\begin{align*}
  \text{(VAR DEFS)} \quad  & (Def(d); cs) \rightarrow \llbracket d \rrbracket_{Def} +  \llbracket cs \rrbracket_{Cmds} \rightarrow ((\gamma;\llbracket d \rrbracket_{Def}),\omega,\upsilon) \\
  \\
  \text{(TYPE DEFS)} \quad & (Def(d); cs) \rightarrow \llbracket d \rrbracket_{Def} + \llbracket cs \rrbracket_{Cmds} \rightarrow (\gamma,(\omega;\llbracket d \rrbracket_{Def}),\upsilon)  \\
  \\
  \text{(GLB EXPR)} \quad  & (Expr(b), cs) \rightarrow \llbracket b \rrbracket_{Expr} \times \llbracket cs \rrbracket_{Cmds}  \rightarrow (\gamma,\omega,\llbracket b \rrbracket_{Expr})
\end{align*}
\subsection{Définitions}\label{duxe9finitions}

\[  d \rightarrow \llbracket d \rrbracket_{Def} \rightarrow \pi \] On définit la relation
\(Def\) selon les cas de construction des définitions. Les cas de
construction des définitions sont donnés par les clauses des règles
syntaxiques.

Une définition est dite traduisible si chacune de ses clauses peut être
traduite. On distingue deux catégories de définitions:

\begin{itemize}
  \tightlist
  \item
        Les définitions de \textbf{Variables Globales},
  \item
        Les définitions de \textbf{Types}.
\end{itemize}

Ces deux catégories de définitions sont traitées différemment par \({Cmds}\)

\begin{itemize}
  \tightlist
  \item
        \(\pi\) est donc la traduction de la définition \(d\) placée dans la
        bonne catégorie.
\end{itemize}
\begin{align*}
  \text{(VARDEF)}
  \quad                  & VariableDef(v, e) \rightarrow  GLB(InsLet(v, \llbracket e \rrbracket_{Expr}))                                   \\
  \\
  \text{(TYPDEF) } \quad & TypeDef(n, [t_1,\dots,t_N], [c_1,\dots,c_N])                                                                    \\
  \rightarrow \;         & \text{TYPE}(TypDef(n, [t_1,\dots,t_N], DefDatatype[\llbracket c_1 \rrbracket,\dots,\llbracket c_N \rrbracket]))
\end{align*}
\subsection{Types}\label{types-2}

\[  t \rightarrow \llbracket t \rrbracket_{Type} \rightarrow t' \] On définit la relation
\({Type}\) selon les cas de construction des types. Les cas de
construction des types sont donnés par les clauses des règles
syntaxiques. Un type est dit traduisible si chacune de ses clauses peut
être traduite.
\begin{align*}
  \text{(TLITT) }  & TypeInt \rightarrow \llbracket TypeInt \rrbracket_{Type}  \rightarrow TypInt                                                                                       \\
  \\
  \text{(TVAR) }   & TypeDefined(id) \rightarrow \llbracket TypeDefined(id) \rrbracket_{Type} \rightarrow TypVar(id)                                                                    \\ \\
  \text{(TTUPLE) } & TypeTuple([t_1,\dots, t_N]) \rightarrow  TypTuple[\llbracket t_1 \rrbracket_{Type},\dots,\llbracket t_N \rrbracket_{Type}]                                         \\
  \\
  \text{(TAPP) }   & TypeConstructor(t, [p_1,\dots,p_N]) \rightarrow  TypApp(\llbracket t \rrbracket_{Type}, [\llbracket p_1 \rrbracket_{Type},\dots,\llbracket p_N \rrbracket_{Type}]) \\
  \\
  \text{(TCLOS) }  & TypeLambda(a,ret)
  \rightarrow \;               TypClosure(Exp, \, (TypFun(TypThunk(\llbracket ret \rrbracket_{Type}), \llbracket a \rrbracket_{Type})))
\end{align*}
\subsection{Litteraux et Expressions}\label{litteraux-et-expressions}

\[ e \rightarrow \llbracket e \rrbracket_{Expr} \rightarrow e'  \]

On définit la relation \({Expr}\) selon les cas de construction
des expr. Les cas de construction des expressions sont donnés par les
clauses des règles syntaxiques. Une expression est dite traduisible si
chacune de ses clauses peut être traduite. \begin{align*}
  \text{(CONSTR)} \quad & Construct(c,e) \rightarrow  ExprConstructor(ConsNamed(c), \llbracket e \rrbracket_{Expr})                                                                  \\
  \\
  \text{(UNARY)} \quad  & CallUnary(op, [a]) \rightarrow  ExprMonPrim(op, \llbracket a \rrbracket_{Expr})                                                                            \\
  \\
  \text{(BINARY)} \quad & CallBinary(op, [a_1,a_2]) \rightarrow  ExprBinPrim(op, \llbracket a_1 \rrbracket_{Expr}, \llbracket a_2 \rrbracket_{Expr})                                 \\                                    \\
  \text{(MATCH)} \quad  & Match(m,[m_1,\dots,m_N]) \rightarrow  ExprMatch(\llbracket m \rrbracket_{Expr}, [\llbracket m_1 \rrbracket_{Case},\dots,\llbracket m_N \rrbracket_{Case}]) \\
  \\
  \text{(BLOCK)} \quad  & Sequence([e_1,\dots,e_{N-1}, e_N])
  \rightarrow  ExprBlock(Blk([\llbracket e_1 \rrbracket_{Expr}; \dots ; \llbracket e_{N-1} \rrbracket_{Expr}], e_N))                                                                 \\
  \\
  \text{(CALL)} \quad   & Call(f, a)                                                 \rightarrow  ExprBlock(Blk([InsOpen(Exp, \llbracket f \rrbracket_{Expr} ),                      \\ & InsForce(ExprMethod(Call, [\llbracket a \rrbracket_{Expr}]))]))                                       \\
  \\
  \text{(LAMBDA)} \quad & Lambda(a, b)                                                                                                                                               \\
                        & \rightarrow  ExprClosure(Exp, ExprGet([GetPatTag(Call, [\llbracket a \rrbracket_{Expr}], ExprThunk(\llbracket b \rrbracket_{Expr}))]))                     \\
  \\
  \text{(REC)} \quad    & FunctionRec(v, a, b)
  \rightarrow  ExprClosure(Exp,ExprRec(\llbracket v \rrbracket_{Expr},                                                                                                               \\  & ExprGet([GetPatTag(Call, [\llbracket a \rrbracket_{Expr}], ExprThunk(\llbracket b \rrbracket_{Expr}))])))
\end{align*}
\subsection{Motifs et Filtrage}\label{motifs-et-filtrage}

\[ Case(p,e) \rightarrow \llbracket Case(p,e) \rrbracket_{Case} \rightarrow \alpha \]

On définit la relation \({Case}\) selon les cas de construction
des motif de correspondance. Les cas de construction des motif de
correspondance sont donnés par les clauses des règles syntaxiques. Un
motif de correspondance est dit traduisible si chacune de ses clauses
peut être traduite.
\begin{itemize}
  \tightlist
  \item
        \(p\) est un motif
  \item
        \(e\) est l'expression qui sera évaluée si le motif est vérifié
\end{itemize}
\begin{align*}
  \text{(PATTAG)} \quad & Case(ConstructorPattern((n,c)), e)
  \\ &\rightarrow  MatchPatTag(ConsNamed(n), \llbracket c \rrbracket_{Case}, \llbracket e \rrbracket_{Expr})        \\
  \\
  \text{(PATVAR)} \quad & Case(VarPattern(x), e, l)
  \rightarrow  MatchPatVar((x, l), \llbracket e \rrbracket_{Expr}, l)
\end{align*}

\end{document}
